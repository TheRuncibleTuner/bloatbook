\chapter{Collections: An Introduction}
\label{chapter:brief-introduction-collections}

Collections are the glue that bind your data together.  Whether 
providing random or sequential access to your data or enabling
look up by value, collections are an essential part of any
design. In Java, collections are very easy to use, and, just as easily, to misuse when
it comes to space. Like much else in Java, they don't come with a price tag
showing how much memory they need. In fact, collections
often use much more memory than you might expect. In most Java applications they are the second largest consumer of memory, after
Strings. It's not unusual for collection overhead to take up between x and y\%
of the Java heap.

This chapter and the next four chapters cover memory-efficient
design and implementation with collections.  Collections can serve many different
purposes in an application. They can be used to implement relationships, to organize data into tables, to build indexing structures, or to associate informal information alongside more structured
data. Collections also have some common themes, no
matter what they are used for. For example, each collection class has certain
costs, and will exhibit certain scaling behavior depending upon where it
sits in a design.  
The next four chapters cover using collections in depth. The chapters are
organized according to the different purposes that collections will be used
for in your application. In each chapter we go through the typical patterns you
will encounter, pointing out the common traps and best practices that will help you avoid memory problems. An
important goal throughout is to help you understand how local decisions
play out at a larger scale.  


\paragraph{Chapter~\ref{chapter:brief-introduction-collections}}.In the next section
of this chapter we give a brief overview of the important issues to watch for in any use of collections. In the final section
of this chapter we then take a look at some of the collections resources available to you,
both in the standard libraries and in some open source alternatives. Before we
start, here is a roadmap of the next four chapters, an in-depth look at the
various uses of collections.

%You can use collections for many different purposes in Java. The next
%four chapters are organized according to the different ways collections will be
%used in your applications. We walk you through the most common usage scenarios,
%pointing out space-saving best practices along with some common traps to avoid.
%Understanding requirements can lead to specialized solutions
%Throughout, the goal is to help you understand how local design choices
%will play out on a larger scale.
%something about solutions?


\paragraph{Chapter~\ref{chapter:representing-relationships}. Representing
Relationships} One of the main reasons to use collections is to implement
multi-value relationships, that let you quickly navigate from an object
to its related objects via references. At runtime each relationship turns into a
large number of individual collection instances. In a product catalog, for example, 
each product object would have a collection
pointing to that product's suppliers, and another pointing to the product's
parts. This chapter covers the issues to watch for in these designs:
keeping the cost of small and empty collections to a minimum; sizing your collections properly; and paying only for functionality
you truly need.

\paragraph{Chapter~\ref{chapter:tables-indexes}. Tables and Indexes} A very
different use of collections is as a way to find your objects.  These
structures may be tables enabling direct access to all
the data of one type, or indexes that let you look up objects by key. These
structures may also be used to guarantee uniqueness. They are often large structures, and
have scaling issues that are very different from designs with lots of small
collections, such as relationships. The main issue in these large
structures is understanding which costs will be amortized as the structure
grows, and which will not. This analysis is particularly important for more complex structures,
such as large multikey and multivalue maps. This
chapter takes you through once such analysis, with multiple design
choices whose scaling behavior is not immediately obvious.

\paragraph{Chapter~\ref{chapter:dynamic-records}. Attribute Maps and Dynamic
Records} Many applications need to store data whose shape is not
known at compile time. For example, your application may use dynamic
queries to retrieve records from a database, or it may use
a runtime configuration file to determine properties associated with
certain objects. Since Java does not let you define new classes on the fly (or at
least, not easily), collections are a natural way to
represent these dynamic records. These designs result in a lot of small collections, and so they share some
issues in common with relationships. The main issue for dynamic data, however, 
is that these designs exhibit a kind of ``inflation'' in the
way the data is stored, making them very big consumers of memory. Each record,
instead of being an object, is implemented as a collection. Each collection's
elements are the fields of the record, each field modeled as an object.
The collections may be arrays, lists, or in the worst case, maps. This chapter shows how, by looking
carefully at your data's requirements and identifying those aspects of the data
that are predictable, there are opportunities for specialized,
space-saving representations.

\paragraph{Chapter~\ref{chapter:additional-collection-behaviors}. Additional
Collection Behaviors} Collections often need to implement functionality that is
orthogonal to their main role as storing and retreiving data.  For example, they
may need to minimize contention when operating in a multithreaded environment,
or be protected from unauthorized updates.  Java collections provide these
capabilities in various ways: through specialized collection classes, as well as
collection wrappers that add (or subtract) functionality on existing collection
classes.  

\section{Designing with Collections}

The cost of different collections can vary greatly, even among choices that
might work equally well in the same situation. For example, a 5-element \class{ArrayList}
with room for growth takes 80 bytes, while an equivalent \class{HashSet} costs 276 bytes, or 3.5 times as much. 
Like other kinds of infrastructure, collections serve a necessary
function, and paying for overhead can be worthwhile.  That is, as long as
the cost is proportional to the benefit, and you are not paying
for functionality you don't need. In the above example, a 70\% space saving
can be achieved if the application can do without the uniqueness checking
provided by \class{HashSet}.  The good news is that there are often a few small
changes you can make to the way you use collections, which can have a big
impact on their footprint.

For example,
the very smallest standard collection is 40 bytes, an \emph{empty}
\class{ArrayList}, and that's only when it's been carefully initialized. 
Otherwise, by default it takes up 80 bytes. That may not sound like a lot,
but if you have a collection deeply nested in your design, there may be
hundreds of thousands or millions of instances.


At the same time, there is much that is not under your control, and the basic
costs of collections are high.  Because the standard collection libraries are
written in Java, they suffer from the same kinds of bloat we've already encountered. They have internal layers
of delegation, and extra fields for features that your program may not
use. Unfortunately, the standard collections provide few levers for
tuning for each individual situation. They were
mostly designed for speed, and as a result space is usually sacrificed. In
addition, the standard APIs can force you into expensive decisions in other
parts of your design, such as requiring you to box scalars that you place in
collections. Given all of this, it is extra important to understand, as early as possible,
what collections are costing you in your implementation. In this and
the next four chapters we show you how to figure out those costs, and how
to avoid some common traps. Armed with this
knowledge you can choose carefully, ensuring that you are not
overpaying for your system's needs.

%Knowing the cost of collections is just the beginning.  
It is not enough to know the cost
of collections in the abstract, but to understand \emph{how they will work in
your design}. This is because the same collection class can have very different
scaling behavior in different situations. For example, a particular map
may be perfect as an index over a large table containing a
million objects. That same map class, however, may be prohibitively expensive
when deeply nested, for example, when each of those
million objects maintains its own side map to store attribute-value pairs that
annotate the object.
%make example more concrete? 
Collections have fixed and variable costs, as we saw
in Section~\ref{scalability}. These costs play out differently
depending on the context in which a collection appears, for example, whether
there are many small nested collections, a few large ones, or some combination
hybrid.  A given collection choice has as a minimum its fixed cost,
whether or not it contains any elements. Fixed costs will add up depending on
how many collection instances there are. The variable cost is the space needed to store each entry. These
 costs accumulate with the total number of
elements in collections, regardless of whether they are spread across a lot of
small collections or concentrated in a few large ones. 
Some collection costs will be amortized as more data is stored, others will only
continue to grow. Collection costs also need to be considered together with the data they are
storing. If you are using very expensive collections to store very small amounts
of data, than your system will have a high overhead ratio, and ultimately your application's ability
to scale will be limited. 
Knowing how to analyze these costs in the context of your design
is the key to ensuring that your system will scale when it is time for
deployment.  
%That is the focus of the next four chapters.
%certain collection classes were designed only to operate at a certain scale

\section{The Standard Java Collections}
\section{Alternative Collections Frameworks}
In addition to the standard Java collections classes, there are a number of
open source collections frameworks available. Many of these frameworks
are designed to give you additional functionality or make it easier to
program. With some exceptions, most are not designed to be efficient from a
space standpoint. While some do make much better use of space, and give you a
better ability to customize for your situation, others actually have a
large footprint for the same functionality as the standard libraries. So as in
anything else, being an informed consumer (by measuring) is the best way to
avoid problems later. Below is a short summary of the most
popular alternative collections frameworks.

Important note: there are many kinds of open source licenses, and all have some
sort of restrictions on usage. Make sure to check with your organization's open
source software policies to see if you may use a specific framework in 
your product, service or internal system.

(TODO: Subsections go here for each major framework. Short summary of each.
Longer section on any framework that has customization of policies or that lets you override
entries. Also a brief subsection on collection classes within other frameworks.)

\section{Summary}

Fixed and variable costs.  Fixed costs may or may not be amortized, depending on
the design.  Variable costs are never amortized at a larger scale.
