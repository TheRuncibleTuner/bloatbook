\chapter{A Brief Introduction to Collections}
\label{chapter:brief-introduction-collections}

\section{Designing with Collections}
Collections are the glue that bind your data together\footnote{By
collections we mean random and sequential access structures, such as lists and
sets, as well as associative structures, such as maps and property-value pairs.}. 
In most Java heaps collections are the second largest consumer of memory,
after Strings.  It's not unusual for collection overhead to take up between
x and y\% of memory. It's very easy to take collections off the shelf
and use them. Collections don't come with a price tag, and like much else
in Java, it is not obvious how much space they use. In fact,
collections often use much more memory than you might expect. For example,
the very smallest standard collection is 40 bytes, an \emph{empty}
\class{ArrayList}, and that's only when it's been carefully initialized. 
Otherwise, by default it takes up 80 bytes. That may not sound like a lot,
but if you have a collection deeply nested in your design, it may have hundreds
of thousands or even millions of instances.

The cost of different collections can vary greatly, even among choices that
might work equally well in the same situation. For example, a 5-element \class{ArrayList}
with room for growth takes 80 bytes, while an equivalent \class{HashSet} costs 276 bytes, or 3.5 times as much. 
Like other kinds of infrastructure, collections serve a necessary
function, and paying for overhead can be worthwhile.  That is, as long as
the cost is proportional to the benefit, and you are not paying
for functionality you don't need. In the above example, a 70\% space saving
can be achieved if the application can do without the uniqueness checking
provided by \class{HashSet}.  The good news is that there are often a few small
changes you can make to the way you use collections, which can have a big
impact on their footprint.

At the same time, there is much that is not under your control.
Because the standard collection libraries are written in Java, they suffer from
the same kinds of bloat we've already encountered. They have internal layers
of delegation, and extra fields for features that your program may not
use. Unfortunately, the standard collections provide few levers for
tuning for each individual situation. They were
mostly designed for speed, and as a result space is usually sacrificed. In
addition, the standard APIs can force you into expensive decisions in other
parts of your design, such as requiring you to box scalars that you place in
collections. Given all of this, it is extra important to understand, as early as possible,
what collections are costing you in your implementation. In this and
the next four chapters we show you how to figure out those costs, and how
to avoid some common traps. Armed with this
knowledge you can choose carefully, ensuring that you are not
overpaying for your system's needs.

%Knowing the cost of collections is just the beginning.  
It is not enough to know the cost
of collections in the abstract, but to understand \emph{how they will work in
your design}. This is because the same collection class can have very different
scaling behavior in different situations. For example, a particular map
may be perfect for implementing an index over a table with a half
million objects. That same map, however, may be prohibitively expensive
when deeply nested, for example, when each of those half
million objects has a side map to store attribute-value pairs that annotate the
object.
%make example more concrete? 
Collections have fixed and variable costs, as we saw
in Section~\ref{scalability}. These costs play out differently
depending on the context in which a collection appears, for example, whether
there are many small nested collections, a few large ones, or some combination
hybrid.  A given collection choice has its fixed cost as a minimum,
whether or not it contains any elements. Fixed costs add up depending on how many collection instances there are. The variable cost is the space needed to store each entry. 
These costs accumulate with the total number of
elements in collections, regardless of whether they are spread across a lot of
small collections or concentrated in a few
large ones. 
Some collection costs will be amortized as more data is stored, others will only
continue to grow. Collection costs also need to be considered together with the data they are
storing. If you are using very expensive collections to store very small amounts
of data, than your system will have a high overhead ratio, and ultimately your application's ability
to scale will be limited. 
Knowing how to analyze these costs in the context of your design
is the key to ensuring that your system will scale when it is time for
deployment.  That is the focus of the next four chapters.
%certain collection classes were designed only to operate at a certain scale

%Collections serve many different purposes.
Collections are used for many purposes in Java.  The next four chapters are
organized according to the different ways collections will be used in your
applications. We walk you through the most common usage scenarios, pointing out
space-saving best practices along with some common traps to avoid. 
%Understanding requirements can lead to specialized solutions
Throughout, the goal is to help you understand how small design choices
will play out on a larger scale.
%something about solutions?

%Move this to std collections section? Along the way, we take a look inside some
% specific library classes that are
% relevant to the discussion.

\paragraph{Chapter~\ref{chapter:representing-relationships}. Representing
Relationships} One of the main reasons to use collections is to implement
multi-value relationships that let you quickly navigate from an object to its
related objects using references. Each relationship typically involves a large number of individual collection instances.  In a
product catalog, for example, each product object might have a collection
pointing to that product's suppliers. In these designs, both fixed and variable costs of collections matter. Chapter~\ref{chapter:}
%focus on not overpaying for functionality.  Small collections. Empties. 
% Growth.

\paragraph{Chapter~\ref{chapter:tables-indexes}. Tables and Indexes} A very
different use of collections is as a way to find your objects. 

\paragraph{Chapter~\ref{chapter:dynamic-records}. Attribute Maps and Dynamic
Records} Many applications need to store data whose shape is not
known at compile time. For example, your application may retrieve
records from a database in response to a dynamic query. Another example is when
you need to associate property-value annotations with each object, where the full set of
properties is specified in a configuration
file loaded at startup time.
% or by the user.
Since Java does not let you define new classes on the fly (at
least, not without a lot of machinery), collections are a natural way to
represent these dynamic records. These solutions are very expensive from a
space standpoint, since there is an``inflation'' in the way the data is
physically stored. Each record, which under normal circumstances would be an
object, is now a collection (typically a list, array, or map), while each
field takes up an entire object.
%In addition, because so much is left to interpret at runtime, performance
% suffers as well.  
In this chapter we walk through the
common patterns of representing dynamic data with collections, and
the costs and pitfalls of these patterns. Designs with dynamic data 
have a lot of small collections, and so they share some issues in
common with relationships. However, dynamic data has some unique requirements, and
these can differ in each situation. Carefully analyzing these
requirements can lead to some specialized solutions, solutions that save a lot
of space.

\paragraph{Chapter~\ref{chapter:additional-collection-behaviors}. Additional
Collection Behaviors} aaa

In the remaining sections of this chapter we take a quick tour of collections
resources that are available to you.  We first look at the standard Java
collections, and then at some open source alternative collection
libraries.

\section{The Standard Java Collections}

\section{Alternative Collections Frameworks}


\section{Summary}


