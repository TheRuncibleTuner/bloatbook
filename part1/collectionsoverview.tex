\chapter{Collections: An Introduction}
\label{chapter:brief-introduction-collections}

Collections are the glue that bind together your data. 
Whether providing random or sequential access, or
enabling look up by value, collections are an essential part of any design.
In Java, collections are easy to use, and, just as easily, to misuse
when it comes to space. Like much else in Java, they don't come with a price tag
showing how much memory they need. In fact, collections
often use much more memory than you might expect. In most Java applications they are the
second largest consumer of memory, after
strings.  Collection overhead typically accounts
for 10-15\% of the Java heap, and it is not uncommon to see much higher numbers
in individual heaps. The way collections are employed can make or break a system's
ability to scale up.

%awareness of costs; thorough analysis of scalability; whether or not will scale
This and the next three chapters are about using
collections in a space-efficient way. We'll look at typical patterns of
collection usage, their costs, and solutions for saving space. We'll see
techniques for analyzing how local implementation decisions play out at a larger scale.
We will also look at the internal design of a few collection classes.



%Each of the following three
%chapters then goes into depth about a specific way that collections can be
%used. 

%Clarifying requirements can lead to specialized solutions
%can suggest space-saving solutions, so that you are not paying for
%functionality you don't need.
%Look inside a few important collection classes
%

\begin{description}
\item[Chapter~\ref{chapter:brief-introduction-collections}.  Collections: An
Introduction]
Collections serve a number of very
different purposes in your application, each with its own best practices as well
as traps. The current chapter
is a short introduction to issues that are common to
any use of collections. It includes a summary of collection resources
that are available in the standard and some open source alternative
frameworks.
\item[Chapter~\ref{chapter:representing-relationships}.
One-to-Many Relationships] An important use of collections is to
implement one-to-many relationships. These enable quick navigation from an
object to related objects via references. This chapter covers the patterns and pitfalls of
implementing these relationships. At runtime, each relationship
becomes a large number of collection instances, with many containing just a few elements.
%In a product catalog, for example, each product object would have one
%collection instance pointing to that product's suppliers, and another pointing
%to the product's parts.
The main issues to watch for
are: keeping the cost of small and empty collections to a minimum, sizing
collections properly, and paying only for features you really need.

\item[Chapter~\ref{chapter:tables-indexes}. Indexes and Other Large Collection
Structures] A collection can serve as the jumping off
point for accessing a large number of objects. For example, your application
might maintain a list of all the objects of one type, or have an index for
looking up objects by unique key. This chapter shows how to analyze the memory
costs of these structures. The main
issue is understanding which costs will be amortized as the structure grows, and
which will continue to increase. The chapter also covers more complex cases,
such as a multikey map, where there is a choice between a single collection and a multilevel design.
% large structures
% compare design alternatives

\item[Chapter~\ref{chapter:dynamic-records}. Attribute Maps and Dynamic
Records] Many applications need to represent data whose shape is not
known at compile time. For example, your application may read property-value
pairs from a configuration file, or retrieve records from a database
using a dynamic query. Since Java does not let you define new classes on the
fly, collections are a natural, though inefficient way to represent
these dynamic records. This chapter looks at the common cases where dynamic records
are needed, and shows how to identify properties of your data that could lead to
more space-efficient solutions.

%\item[Chapter~\ref{chapter:additional-collection-behaviors}. Additional
%Collection Behaviors] Collections sometimes need to support additional features
%beyond data storage and access. For example,
%you may need to protect a table from inadvertent
%updates, or minimize contention on a map when running in a
%multithreaded environment. Java collections provide these capabilities through
%specialized classes, or through wrappers that alter
%the operation of other collections. This chapter covers the costs of
%these collections.  The granularity
%at which you use them can have a big impact on their memory
%cost.

\end{description}

%Across all of these different uses, collections have some common themes.
%The next section is an overview of issues to
%be aware of in any use of collections. It is followed by a
%survey of collections resources available in the
%standard libraries and some open source alternatives.

\section{The Cost of Collections}
%\section{Designing with Collections}
\label{sec:designing-with-collections}

\paragraph{Choosing carefully}Like other
building blocks in Java, the memory costs of the standard collections are high overall. 
The very smallest of the commonly-used collections, an \emph{empty}
\class{ArrayList}, takes up 40 bytes, and that's only when it's been carefully
initialized. By default it takes 80 bytes. That may not sound like a lot by
itself, but when deeply nested in a design, that could easily be multiplied
by hundreds of thousands or millions of instances.  

There is much that is not under your control in the cost
of collections.
Because the collection libraries are written in Java, they suffer
from the same kinds of bloat we've seen in other datatypes. They have
internal layers of delegation, and extra fields for features that your program
may not use. Some
collection classes have a few options that can help, such as
letting you specify excess capacity allocated initially. On the
whole, though, they do not provide many levers for tuning to different situations. They were
designed mostly for speed rather than space. They seem to have been designed
for applications with a few large and growing collections. Yet many systems have large numbers
of small collections that never grow once initialized. Given all of this, it is important
to be aware of what collections cost, so you can make informed choices as early as possible. 

%In addition, the standard APIs can force you into expensive
%decisions in other parts of your design, such as requiring you to box scalars
%that you place in collections. 
%In this and
%the next four chapters we show you how to figure out those costs, and how
%to avoid some common traps. Armed with this
%knowledge you can choose carefully, ensuring that you are not
%overpaying for your system's needs.

%Even with high costs in general, there are some things that you do
%have some choice over, such as which collection classes to use, and how they
%are initialized.

%and how your data is
%structured to use them effectively. (move to scalability section?)


Fortunately, there are some easy choices you can make that
can save a lot of space. The best thing you can do is to choose carefully
among collection classes. Costs vary
greatly, even among collection classes that may work equally well
in the same situation. 
%making it all the more important to become familiar with what
%collections cost. 
For example, a 5-element \class{ArrayList} with room for growth takes 80 bytes. 
An equivalent \class{HashSet} costs 256 bytes,
or more than 3 times as much. Like other kinds of infrastructure, collections
serve a necessary function, and paying for overhead can be worthwhile. That is, as long as you are not
paying for features you don't need. In the above example, a
69\% space savings can be achieved if the application can do without features
such as uniqueness checking that
\class{HashSet} provides. In Section~\ref{sec:better-designs} we saw a similar
example, achieving a large improvement when real-time
maintenance of sort order wasn't needed. In the next chapters we'll see more
examples of how understanding your system's requirements, along with what
collections cost, can help you make large reductions in memory. 
In general we do not recommend implementing your own collections, at least not
until you've exhausted all other possibilities.

\paragraph{Understanding costs} Collections are pure overhead. Collections are
variable in size, dependent upon the elements they contain. A given
collection class will scale differently in different situations, and it's
important to understand \emph{how a particular collection class
will work in your design}. Some collections were only designed
to be used at a certain scale.
%the same collection
%class will scale differently in different situations. 
For example, a certain map class may work
well as an index over a large table, but can be prohibitively expensive when you
have many instances of it nested inside a multilevel index. 

Each collection class has its own cost
profile that determines how it will scale. This is its fixed
and variable costs, as discussed in Section~\ref{sec:scalability}. 
The fixed cost is the minimum space needed with or
without any elements; the variable cost is the additional space needed to
store each element. The way these costs add up
depends on the context ---
whether there are many small collections or a few large ones. 
High fixed costs take on more significance in smaller collections,
especially when there are many instances of them. High variable costs matter
when there are a lot of elements, regardless of whether the elements are spread across
a lot of small collections or concentrated in a few large ones.
We'll analyze the space needs of very small collections (with number of elements
roughly in the single digits) a little differently from those of larger
collections.
Tables~\ref{tab:small-collections-default} through \ref{tab:empty-collection-costs} in
\autoref{chapter:representing-relationships} show the overhead cost of small and empty collections for some commonly-used
collection classes. The following chapter shows
how to compute costs for larger collections.
\autoref{chapter:jre-comparison} gives more comprehensive information for
additional classes and platforms.



%Collections with high fixed
%costs should only be used for large collections, so that the fixed cost will
%be amortized over a large number of elements.  


%Some collection costs will be amortized as
%more data is stored, others will only continue to grow. 
%Certain collections are designed
%to be used at a certain scale --- when there are a few large collections, not a
%lot of smaller ones.  
It is helpful to look at collection costs 
together with the data they are storing. If a data structure uses expensive collections
to store small amounts of data, than it
will have a high bloat factor, and ultimately the application's ability to
support a large amount of data will be limited. The next chapters show
how to analyze collection costs in the context of your design.
% to ensure that your system will scale when it is time for deployment.
This analysis will help you choose the right collection for your design, or
restructure your data into a more efficient design if necessary.


\section{Collections Resources}

%In the next four chapters we will look in detail at how various
%collection classes can best be used in different situations. 

In this book we focus
mostly on the standard collections. We also include information 
about some alternative, open source frameworks that can be helpful in keeping
memory costs down.

% just a selection throughout the book.  Encourage the reader to explore more
% for themselves.

\paragraph{The Standard Collections} There are some
lesser-known resources in the standard Java Collections framework that provide specialized functionality. Some can help you
save memory if you require only those features.  Others provide useful
features, but can have a significant memory cost if not used carefully.
Table~\ref{tab:lesser-known-collections} is a guide to the resources we discuss
in this book.

\begin{table}
\centering
	\begin{tabular}{l p{6cm} p{4cm}}
	\toprule

	   Resource & Description & Discussed in
	\\ \cmidrule(r){1-1} \cmidrule(l){2-2} \cmidrule(l){3-3}
	\class{Collections} statics & Memory-efficient
	implementations of empty and singleton collections. &
	Sections~\ref{sec:empty-collections}, \ref{sec:mostly-small-collections}
	\\ 
	& Unmodifiable and synchronized
	behaviors are added via collection wrappers. Can be costly if used at too fine
	a granularity. & Sections~\ref{sec:unmodifiable-collections},
	\ref{sec:synchronized-collections}
	\\
	\class{Arrays} statics & Provides static methods if you need to create
simple collection functionality from arrays & Section~\ref{sec:better-designs}
shows one example
	\\
	\class{IdentityHashMap} & Lower-cost map when using an object reference as key
	& %Section~\ref{}
	\\
	\class{EnumMap} & Compact map when keys are \class{Enum}s & %Section~\ref{}
	\\
	\class{EnumSet} & Compact representation of a set of flags &
	Section~\ref{sec:bit-flags}
	\\
	\class{WeakHashMap} & Supports one common scenario for managing object lifetime
	using weak references. &
	%Section~\ref{}
	\\
	Java 1 collections & Some classes in the earlier, Java
1 libraries, like Vector and Hashtable, are a lower-cost choice 
in some contexts where synchronized collections are needed &
Section~\ref{sec:synchronized-collections}
	\\
	\class{ConcurrentHashMap} & Hash map when contention is a concern. Avoid use at
	too fine a granularity. & %Section~\ref{}
	\\
	\bottomrule
	\end{tabular}
	\caption{Some useful resources in the Java standard library}
	\label{tab:lesser-known-collections}
\end{table}


\paragraph{Alternative Collections Frameworks} In addition to the standard Java
classes, there are a number of open source collections frameworks available. Some are designed
specifically to improve space and time efficiency, while others are aimed at
making it easier to program, adding commonly needed features not
found in the standard libraries. 
The alternative collections frameworks can be helpful in two ways when it comes to saving memory. First,
some frameworks provide space-optimized collection implementations. Second, some frameworks
provide classes that make it easier to manage object lifetime. Building your
own object lifetime management mechanisms, for example a concurrent cache, can
be error-prone (see, for example, Section~\ref{}). Well-tested implementations
will save you a lot of effort, and can lead to better overall use of space.
Keep in mind that not all alternative collection classes have
been optimized for space.
Some of them actually take up more space than a similar design using the
standard collections. As always, there is no substitute for analyzing space costs empirically.
%analyzing space usage yourself


In this book we'll look at four of the most recent and relevant
open source collections frameworks. In the next few chapters we'll look at how
you can use some of these classes to solve specific problems.
Table~\ref{tab:alternative-collections} gives a summary of the capabilities that
we discuss (sometimes only briefly). This is only a sampling of what's out
there. We encourage you to further explore these and other frameworks on your own.
%on your own

The Guava framework, which grew out of the Google Collections, is
designed primarily for programmer productivity, providing many useful
features missing from the standard Java collections. 
Although space usage has not been the main focus, it does include some
specialized classes, for example the immutable collections, that are more
space-efficient than their general-purpose equivalents. Guava's \class{MapMaker}
class provides very general support for 
building caches and other lifetime management mechansisms, with optional support
for concurrency. While most open source frameworks provide some level of compatibility with the
standard collections APIs, Guava has made compatibility a priority.

The Apache Commons Collections framework has similar objectives to the Guava
framework, focusing mostly on programmer productivity rather than on
efficiency per se. 
%Of the two, Commons has been around longer. However, as of this writing it
% there have not been recent releases, 
It does however provide some capabilities for saving memory, such as
maps and linked lists with customizable storage, and specialized 
maps that contain just a few elements. It also provides lifetime management
support through its \class{ReferenceMap} class, in a less general
manner than the Guava equivalent. As of this writing,
the Commons API has not been updated to take advantage of generics.

The GNU Trove framework has time and space efficiency as its main goal.
From a memory standpoint its highlights are: collections of primitives that
avoid boxing and unboxing;  map
and set implementations that are lighter weight than the standard ones; and
linked lists that can be customized to use less memory.

The fastutil framework has similar goals to Trove, primarily time and space
efficiency. Like Trove, fastutil provides primitive collections, along with
lighter-weight implementations of maps and sets. Some other memory-related
features include array-based implementations for small
maps and sets, and support for very large arrays and collections when working
in a 64-bit address space.

Important note: there are many kinds of open source licenses. Each has different
restrictions on usage. Make sure to check with your organization's open
source software policies to see if you may use a specific framework in 
your product, service or internal system.

\begin{table}
\centering
	\begin{tabular}{p{6cm} p{3cm} p{4cm}}
	\toprule

	   Feature & Supported by & Discussed in
	\\ \cmidrule(r){1-1} \cmidrule(l){2-2} \cmidrule(l){3-3}
	Primitive collections & fastutil, Trove & Section~\ref{}
	\\
	\\
	Lighter-weight maps and sets of objects & fastutil, Trove & Section~\ref{}
	\\
	\\
	Immutable collections & fastutil, Guava & Section~\ref{}
	\\
	\\
	Small collections & Commons (maps only), fastutil & Section~\ref{}
	\\
	\\
	Customized linked list storage & Trove & Section~\ref{}
	\\
	\\
	Maps with weak/soft references & Commons, Guava & Chapters~\ref{} and ~\ref{}
	\\
	\\
	Caches & Guava & Section~\ref{}
	\\
	\bottomrule
	\end{tabular}
	\caption{A sampling of memory-related resources available in open source
	frameworks}
	\label{tab:alternative-collections}
\end{table}

%collection classes buried in other frameworks

\section{Summary}
Using collections carefully can
make the difference between a design that scales well and one that
doesn't. Some items to be aware of when working with collections:
\begin{itemize}
  \item The standard Java collections were designed more for speed than for
  space. They are not optimized for some common cases, such as designs with many small
  collections. In general the Java collections use a lot of memory.
 %not designed for the ways they are actually used.
  \item Collections vary widely in their memory usage. Awareness of
  costs is an essential first step in choosing well. Sometimes there is a less
  expensive choice of collection class available, either from the standard
  library or from open source alternatives. Initialization options can also make
  a difference.
  \item The same collection class will scale differently depending on its
  context. Ensuring scalability means
  analyzing how a collection's fixed and variable costs
  play out in a given situation. Watch out for: collections with
  high fixed costs when you have a lot of small collections, and 
  collections with high variable costs when you have a
  lot of elements.
  \item Analyzing your application's requirements, specifically
  which features of a collection you really need, can suggest
  less expensive choices.
\end{itemize}
