\chapter{Specialized Collections}


Multikey

I said this was a pretty common programming idiom, and in fact I was looking around the Apache commons collections, which is a fairly nice, open source set of collections, they have something called a multikey map. Great, maybe they are solving this already. They have, like every other collection, they have a wrapper object, and then they have an array, and inside that it’s an array of these multi-key objects, and I thought this is nice, you’ll subclass this thing, and then you’ll be done. Instead what they do is that in turn delegates to another array, which has the different parts of the key in it, and your keys get added to that. So in fact, this is even more expensive, maybe it’s about the same, because it has a wrapper multikey which is equivalent to an arraylist object, and then the array is just like the array that was inside the array list. So the could have easily implemented something. There are calls in this class, there’s a put call with 2 keys, and a put call with 3 keys, and a put call with 4 keys, so they could have easily have specialized this, and had a multikey 2, and a multikey3, and so forth that were subclasses of multikey, that had the right number of fields in it. But, it was just the focus here. SO that’s another 20bytes per entry in this case also. Frankly, as I looked around at a lot of the standard collections out there, there’s just no attention to footprint. 

CONCURRENT MAPS

So now some special cases in this. There are a lot of different uses of this, and one interesting things we’ve been learning, as we’ve been looking at all these case studies is that we’re really trying to think about why are people using collections, and what are they using them for? In the last example, we saw, they are using them to implement a map. A fairly complicated map. In that first long example. 

This example was from one fo the SameTime products, Lotus server-side products. I have a lot of Lotus examples here, only because we’ve worked with the a lot. Not because their code is worse than anyone elses. This is a pervasive problem. 

So in this case, this is the sametime gateway actually, and what it’s doing is keeping track of active chat sessions. Example is a bit simplified. They need to handle some gigantic number of concurrent sessions. So they use a concurrent hashmap, the standard Java concurrent hashmap, and in that they store sessions. Each session has some number of subscribers, and so within each session they use a concurrent hashmap to store the subscribers. When we look at this together, everyone was in shock that this concurrent hashmap thing was so huge. And again this was a relatively small run, but even for this, we didn’t expect there to be 177MB of concurrent hashmap. And so we looked at it, and it turns out they took all the defaults for concurrent hashmap, and each concurrent hashmap costs 1700 bytes, approximately. The reason for that is that the concurrent  hashmap is really designed for high concurrency, so it contains 16 parallel hashmaps by default, each with 16 elements. Now if you only have a few subscribers, most of that stuff is empty. So when the developers saw this, they immediately realized, we don’t need that kind of concurrency control. We don’t have thousands of subscribers on the same session. We need that concurrency on a higher level. Sure, we need a concurrent hashmap up here to manage hundreds of thousands of sessions, but each session is only going to have a few subscribers. So we can greatly limit the number of concurrency we can support there, as long as it’s thread safe. So one developer suggested, ok , let’s just take the concurrent hashmap, and choose the default as 3 instead of 16. With that, they could have gotten a reduction of 67%, which is substantial, but then one of the other developers suggested let’s just use HashTable, because it’s much, much smaller, and it’s still threadsafe. So hashtable was a great choice for the sametime people, as it turned out.

UNMODIFIED MAP

So here’ another example, of unmodifiable, now this was from NetFlix, which Nick analyzed, it was an IBM customer, and in this case, we don’t know exactly what this was, some kind of cache of titles they maintained, and it had also a 2-level structure to it, and it had in this particular run 2 million of these inner maps, taking up about .5G, and when we looked inside there, what we found, was that each of those maps was an unmodifiable map, wrapping a smaller hashmap, so they had 2 problems. One was why they had the small hashmaps, and that’s a separate issue, but even the unmodifiable hashmap was pretty substantial. This was a 64 bit JVM, I think this was a SUN JVM, so the cost was even double of what we say before, it was 56 bytes for each of these wrappers. It was a pretty hefty cost. So this is the kind of thing where – this is a functionality that. Unmodifiable is pretty useful for development time, to avoid programming errors, but it’s not clear that especifallly, this fine grain, that in deployment you would want to keep a feature like that in there, this is pretty expensive.  

There’s a whole set of Java wrapped collections, for type checking, for modifiable, and that’s the general pattern. That’s a nice programming pattern, and it certainly simplified the class hierarchy. I read some of the notes from the designers of these collection classes, about why they made these choices, and they said it would just have complicated the class hierarchy in the Java collection classes to have all these combinations there. And that makes perfect sense when you have a few large collections. But in this kind of case, when you have lots and lots of small collections, it really adds up. On this JVM, this is 1.4.2, maybe this we sun 1.5 the cost is 28 bytes per each of these wrapper objects, which is pretty substantial. So that’s including its header, its bookkeeping, and the pointers. That’s ok for large collections, for small collections, it really adds up. 


