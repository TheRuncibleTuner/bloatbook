\chapter{Indexes and Other Large Structures for Accessing Data}
\label{chapter:tables-indexes}

In a relational database system, data is neatly organized into tables for you. 
In object-oriented programming languages you have more freedom. You have a sea
of interconnected objects, and you are
responsible for designing structures that are the entry points into your
data.  Collections, especially large collections, are the
main tool you have. In this chapter we look at the memory considerations when
designing collection structures for finding or gathering together your
data. The bulk of the chapter is about indexes that let you look up data by
value. We also look briefly at structures that simply collect your data together, such as
a list of all the objects of one type. 

We start by looking at single large
collections, whether lists, sets, or maps.  The same principles apply in any
large collection: the overhead cost is dominated by the
incremental overhead of adding each new element.  There are a number of
collection choices you can make with very different overhead costs, in both the
standard libraries and in open source frameworks if you are able to use them in your system. We'll look
at how choosing carefully can make a big difference.  We
next look at a number of special cases. If your requirements fit into one of
these cases, there are some less expensive solutions
available. The remainder of the chapter is about composite structures that have
multiple levels of maps and other collections. We look at three representative cases: 
an index with a multipart key, a multilevel concurrent index, and a multimap (a non-unique index). 
The costs of composite structures are not always obvious, since fixed and variable costs of collections
at different levels can all limit scalability. Without a careful analysis, it's easy to create very expensive designs.
For the multikey index we walk through a sample analysis, comparing
three alternative designs.

%In any large collection, the main
%issue is how to keep down the cost of adding an element. The fixed
%cost of the collection becomes insignificant once the collection is above a
%certain size.  We look at ways to keep these variable costs down: by
%carefully choosing the right collection for the situation; by
%recognizing some special cases that enable some optimizations; and by using
%some of the open source collection classes if they are available to you
%(rephrase all of this is what the reader can do, not as a roadmap).


\section{The Costs of Large Collections}

\subsection{Entry- vs. Array-based Collections}

\section{Canonicalizing Maps}

\section{Identity Maps}

\section{Maps with Scalar Keys or Values}

\section{Multikey Maps. Example: Evaluating Three Alternative Designs}

\section{Concurrency and Multilevel Indexes}

\section{Multivalue Maps}

\section{Summary}

