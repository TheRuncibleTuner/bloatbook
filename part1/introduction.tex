
\chapter{Introduction}

Managing your Java program's memory couldn't be easier, or so it would
seem. Java provides you with automatic garbage collection, and a compiler that
runs as your program is running and responds to its operation. There are many
standard, open source, and proprietary libraries available that provide powerful
functionality, and are written by experts. All you have to do is piece together
the parts and let the Java runtime system do the rest for you.

The reality, unfortunately, is very different. If you just assemble the parts, take
the defaults, and follow all the good advice to make your
program flexible and maintainable, you will likely find that your memory needs are
\emph{much} higher than imagined. You may also find that precious memory
resources are wasted holding on to data that is no longer needed, or that
CPU cycles are wasted re-creating data that was just thrown away. 
You may discover, when you are ready to ship, that your design is very far from
fitting into memory, or that it does not support nearly the number of users it
must support. (Indeed, properly predicting and engineering 
your system's memory needs, early in the cycle, can make the
difference between success and failure of your project.)

Achieving efficient memory usage takes some effort in any language, yet
there are things about Java that make it very easy to end up with bloated or even incorrect
data designs. In part it's because Java is so easy to program, it gives you a
false sense of security that everything is being handled for you. (Languages like C give you a
lot of control over storage, and so it is clear what
the consequences of your choices are.) Also, as we shall see,
the basic costs of building blocks such as Strings, can be surprisingly expensive,
when compared with languages like C++. So much is done for you in
Java, from management of the heap, to all the functionality hidden behind framework APIs, that it can be
difficult to know how much memory your data structures need, or how long they are staying around, until you have
a fully running system. Compared to languages like C++, Java also gives you fewer options for designing your
data structures and managing their storage. This means that if you find you have problems, you may have fewer
ways of fixing them without rethinking larger aspects of your design.

All of this makes it even more important to understand what memory costs and alternatives are, as early as possible

This book is a guide to using memory wisely in Java. Memory usage, like any other
aspect of software, needs to be carefully engineered if your system is to be successful.
Engineering requires making informed tradeoffs, and, unfortunately, the information
about space isn't always available. 
While there has been much written on how to build systems that are bug-free, easy to maintain, and secure,
there is little guidance available on how to use Java memory efficiently
or even correctly. (Too often memory issues are left to chance, or at least
put off until there is a crisis.)  This book gives you the tools to do that.
It gives you 
an approach to looking at your system's uses of memory, and a practical guide
to making informed tradeoffs in every part of your design and
implementation.  (Common patterns that make up your design - helps you understand costs and alternatives.  Also 
relevant Java mechanisms).

If you are like most Java developers, you probably don't have a good picture of
of how much memory your designs use.

Beyond the technical realities of using memory well in Java there are some commonly held misconceptions that often make things worse. So before getting into how to engineer memory in Java, it is worth dispelling some
of these myths, and getting a better understanding of why memory problems
can be so common in Java.

\section{Facts and Fictions}

not so easy, and is extremely important for your system's success, because of Java and the use of so
many frameworks (current style of programming)

So much is hidden
Expensive compared to other languages
Problems can pile up
Limited choices compared to other languages.


There are some common beliefs that can get in the way 
Before getting into too much technical detail, ... The next section dispels some common misconceptions about memory in Java.  These misconceptions can get in the way of making 


\section{Some Common Misconceptions About Memory}

In addition to the technical reasons why managing memory can be a challenge, there
are other reasons why memory footprint problems are so common. In particular,
the software culture and popular beliefs can lead you to ignore memory
costs. Some of these beliefs are really myths --- they might have once
been true, but no longer. Here are several.

\section{Memory-concious Engineering}

At a high level, the approach we present in this book is simple. For each part of your data design:
- understand the space needs of the various implementation alternatives
- determine how long that data should remain alive, and then choose an appropriate implementation to achieve that

The bulk of this book takes you through the most common patterns that come up in practice for each topic. We show you how to recognize
these patterns in your designs, and give you relevant information about costs and other pitfalls.  

%very high level overview of approach goes here

\subsection{Estimating Space Costs}

%discuss estimating (Edith text on counting bytes, etc is great)

%discuss health very briefly

%discuss entities and collections

\subsubsection{Entity-Collection Diagrams}

Much of this book is about how to implement your data designs to make the most efficient use of space. In this section we introduce a diagram, called the \emph{entity-collection(E-C) diagram}, that helps with that process. It highlights the major elements of the data model implementation, so that the costs and scaling consequences of the design are easily visible. We use these diagrams throughout the book to illustrate various implementation options and their costs.

A data model implementation begins with a conceptual understanding of the entities and relationships in the model.  This may be an informal understanding, or it may be formalized in a diagram such as an E-R diagram or a UML class diagram.  At some point that conceptual model is turned into Java classes that represent the entities, attributes, and assocations of the model, as well as any auxiliary structures, such as indexes, needed to access the data.  The example below shows a simple conceptual model, using a UML class diagram.  A Java implementation of that model is also shown, using rectangles for classes and arrows for references.  %The Java diagram below is typical of a schema diagram, in that it shows 

While the Java 

In these models we make a distinction between the implementations of entities and the implementation of collections.  We do this for a number of reasons.  First, the kinds of choices you make to improve the storage of your entities are often different from those Collections are also depicted as nodes, using an octagonal shape.  This is different from UML class diagrams, where associations are shown as edges. E-C diagrams show 

\subsection{Managing lifetime}


\subsection{Defining Terms}

Terms like object can have different meanings in the literature.  The following are the conventions for terms used throughout this book.

Since the word \textit{object} can have different meanings, we precisely define the terminology used:
\begin{itemize}
\item A \textit{class} is a Java class. A class name, for example \texttt{String}, always appears in type-writer font. 
\item A \textit{data model} is a set of classes that represents one or more logical concepts.
\item Finally, an \textit{object} is an instance of a class, that exists at runtime occupying a contiguous section of memory.
\end{itemize} 







 

