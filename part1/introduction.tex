
\chapter{Introduction}

Managing your Java program's memory couldn't be easier, or so it would
seem. Java provides you with automatic garbage collection, and a compiler that
runs as your program is running and responds to its operation. There are many
standard, open source, and proprietary libraries available that provide powerful
functionality, and are written by experts. All you have to do is piece together
the parts and let the Java runtime system do the rest for you.

The reality, unfortunately, is very different. If you just assemble the parts, take
the defaults, and follow all the good advice to make your
program flexible and maintainable, you will likely find that your memory needs are
\emph{much} higher than imagined. You may also find that precious memory
resources are wasted holding on to data that is no longer needed, or, even
worse, that your system suffers from memory leaks. Java is filled with
costly memory traps that are easy to fall into.  All too often, these problems
won't show up until late in the cycle, when the whole system comes together. 
You may discover, for example, when your product is about to ship, that your design is
far from fitting into memory, or that it does not support nearly the number
of users it needs to support. Fixing these problems can
take a major effort, requiring extensive refactoring or rethinking
architectural decisions, such as the choice of frameworks you use.

This book is a guide to using memory wisely in Java. Memory usage,
like any other aspect of software, needs to be carefully
engineered. Predicting
your system's memory needs early in the cycle, and engineering with those needs in mind, can make
the difference between success and failure of your project. Engineering means making
informed tradeoffs, and, unfortunately, the information
to do so isn't always available. While there has been much written on how to
build systems that are bug-free, easy to maintain, and secure,
there is little guidance available on how to use Java memory efficiently
or even correctly. (Too often memory issues are left to chance, or at least
put off until there is a crisis.)  This book gives you the tools to make
informed choices early on.  It gives you 
an approach to looking at your system's uses of memory, and a practical guide
to making informed tradeoffs in every part of your design and
implementation.  (Common patterns that make up your design - helps you understand costs and alternatives.  Also 
relevant Java mechanisms).  Three kinds of info: patterns, mechanisms, and an
organization/approach to thinking about memory.

(If you are like most Java developers, you probably don't have a good picture of
of how much memory your designs use.)

Achieving efficient memory usage takes some effort in any language. 
There are things about Java that make it especially easy to end up with bloated
or even incorrect data designs. One reason is that Java is so easy to program,
so it gives you a false sense of security that everything is being handled for you. (Languages like C give you a
lot of control over storage, and so it is clear what
the consequences of your choices are.) Also, as we shall see,
the basic costs of building blocks such as Strings, can be surprisingly expensive,
when compared with languages like C++. So much is done for you in
Java, from management of the heap, to all the functionality hidden behind framework APIs, that it can be
difficult to find out how much memory your data structures need, or how long
they are staying around, until you have a fully running system. Compared to
many languages, Java also gives you fewer options for designing your data
structures and managing their storage. This means that if you find you have
problems, you have fewer ways of fixing them without rethinking larger aspects of your design.
All of this makes it important to understand what memory
costs and alternatives are, as early as possible.


Beyond the technical realities of using memory well in Java there are some commonly held misconceptions that often make things worse. So before getting into how to engineer memory in Java, it is worth dispelling some
of these myths, and getting a better understanding of why memory problems
can be so common in Java.

\section{Facts and Fictions}
%\section{Some Common Misconceptions About Memory}

In addition to the technical reasons why managing memory can be a challenge, there
are other reasons why memory footprint problems are so common. In particular,
the software culture and popular beliefs can lead you to ignore memory
costs. Some of these beliefs are really myths --- they might have once
been true, but no longer. Here are several.

\section{Memory-conscious Engineering}

At a high level, the approach we present in this book is simple. For each part of your data design:
- understand the space needs of the various implementation alternatives
- determine how long that data should remain alive, and then choose an appropriate implementation to achieve that

The bulk of this book takes you through the most common patterns that come up in practice for each topic. We show you how to recognize
these patterns in your designs, and give you relevant information about costs and other pitfalls.  


\subsection{Estimating Space Costs}

discuss estimating (Edith text on counting bytes, etc is great) (including scalability discussion)

discuss health very briefly

discuss entities and collections

\subsubsection{Entity-Collection Diagrams}

Much of this book is about how to implement your data designs to make the most efficient use of space. In this section we introduce a diagram, called the \emph{entity-collection(E-C) diagram}, that helps with that process. It highlights the major elements of the data model implementation, so that the costs and scaling consequences of the design are easily visible. We use these diagrams throughout the book to illustrate various implementation options and their costs.

A data model implementation begins with a conceptual understanding of the entities and relationships in the model.  This may be an informal understanding, or it may be formalized in a diagram such as an E-R diagram or a UML class diagram.  At some point that conceptual model is turned into Java classes that represent the entities, attributes, and assocations of the model, as well as any auxiliary structures, such as indexes, needed to access the data.  The example below shows a simple conceptual model, using a UML class diagram.  A Java implementation of that model is also shown, using rectangles for classes and arrows for references.  %The Java diagram below is typical of a schema diagram, in that it shows 


In these models we make a distinction between the implementations of entities and the implementation of collections.  We do this for a number of reasons.  First, the kinds of choices you make to improve the storage of your entities are often different from those Collections are also depicted as nodes, using an octagonal shape.  This is different from UML class diagrams, where associations are shown as edges. E-C diagrams show 

\subsection{Managing lifetime}

discuss overview of approach to lifetime management

\subsection{Defining Terms}

Terms like object can have different meanings in the literature.  The following are the conventions used throughout this book.

Since the word \textit{object} can have different meanings, we precisely define the terminology used:
\begin{itemize}
\item A \textit{class} is a Java class. A class name, for example \texttt{String}, always appears in type-writer font. 
\item A \textit{data model} is a set of classes that represents one or more logical concepts.
\item Finally, an \textit{object} is an instance of a class, that exists at runtime occupying a contiguous section of memory.
\end{itemize} 







 

