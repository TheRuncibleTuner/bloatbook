\chapter{Representing Field Values}
\label{chapter:representing-values}

So far, we have been concerned with the wasteful overhead that results from
data representation. But what about the data itself?
Java gives you a number of different ways to represent common datatypes, such
as strings, numbers, dates, and bit flags. Depending on which
representation you choose, the overhead costs can vary quite a bit. 
These costs, hidden in the implementation, are not obvious, and can be
surprisingly high.
In this chapter, we look at the costs of different representations for the most 
commmon datatypes.

\section{Character Strings}
String is the most common non-trivial datatype found in Java programs. We
discuss when to use a Java \class{String} to represent data, and when not to.
\paragraph{External vs. Internal Datatype Forms}
Character strings are the universal data type, in that all data can be
represented in string form.  For example, I am now typing the integer 347 as a
string of characters in this paragraph, and it is stored in a file as a sequence
of characters. Similarly decimal numbers, dates, and boolean values can be
represented as character strings.
 
In Java programs, it's very common to see scalar data represented as instances
of the Java \class{String} class. This representation makes some sense if the
data is read in and/or written out as characters, since it avoids the
cost of conversion. However, there are several good reasons why it's better
to represent data as scalars whenever possible. First, if you need to perform
any kind of operations on the data, you will need to convert it to use
available datatype operators. If these conversions are performed
repeatedly, then there may be lots of temporaries generated needlessly.  Second,
representing data with specific data types leads to better type checking to avoid bugs. 
Finally, specific data types provide a simple form of documentation.
In addition, the overhead of a string representation is much higher than
the overhead of scalars and even of boxed forms.

\begin{table}
  \centering
\begin{tabular}{llr} \toprule \toprule
& Example & Size \\ \midrule \midrule
INTEGER & int anint = 47 & 4 \\
\midrule
& Integer anint = new Integer(47); & 4+16  \\
\midrule
& String anint = new String(``47''); & 4+48 \\
\midrule
\midrule
BOOLEAN & boolean abool = 1 & 1\\
\midrule
& Boolean abool = new Boolean(true): & 4+16 \\
\midrule
& String abool = new String(``true''); & 4+48 \\
\midrule \midrule
ENUMERATION & enum Gender {MASCULINE, FEMININE, NEUTER}; &\\
& Gender aGender = MASCULINE; & 4 \\
\midrule
& String agender = new String(``masculine''); & 4+48 \\
\bottomrule \bottomrule
\end{tabular}

\caption{The cost of different ways to represent an integer, a boolean, and an
enumerated type. The size column shows both the field size and the cost of
additional delegated objects.}
\label{tab:data-sizes}
\end{table}

Table~\ref{tab:data-sizes}

.  Mention
bloat factor from one or two examples from the little table below.




- short table with 3 most common examples, comparing cost of scalar
vs. boxed form vs. String form.  Examples: int (95\%), boolean (using ``Y''
and ``N''), and enum. 

\paragraph{StringBuffer vs. String}

It is well-known that \class{StringBuffer} is more efficient than
\class{String} for performing string concatenation. Since \class{String}s are
immutable, concatenating \class{String}s involves allocating a temporary
\code{char} array, copying the \class{String}s into it, and then constructing
a result \class{String}. A \class{StringBuffer}, on the other hand, is mutable.
If the \class{StringBuffer} capacity is sufficient, then \class{String}s
can be concatenated by simply appending them to the \class{StringBuffer}.

However, long-lived \class{StringBuffer}s can waste memory. Usually a
\class{StringBuffer} is 40\% empty space, since they double in size whenever
they need to be reallocated. Typically, after a string is built up in the
\class{StringBuffer}, it is stable, at which point it should be converted 
to a \class{String}, so that the \class{StringBuffer} can be
garbage collected. Using \class{StringBuffer}s to facilitate
building a \class{String} is fine, but they should be used only as temporaries.

\section{Representing Bit Flags}
\label{sec:bit-flags}
TOWRITE:
- Discuss/compare cost of three representations: a bunch of boolean fields, a
byte with bit flags that you manage yourself, EnumSet.

\section{Dates}
TOWRITE:
- Discuss/compare cost of three representations: Date vs. Calendar vs. time in
millis.  Advice on when each is appropriate.

\section{BigInteger and BigDecimal}
TOWRITE:
- Discuss need for these, and costs.  - Describe the number of objects in each
(I don't think we need a diagram). - Compare to long/double.
