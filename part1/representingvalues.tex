\chapter{Representing Field Values}
\label{chapter:representing-values}

So far, we have been concerned with the wasteful overhead that can result when
modeling entities as classes and fields. But what about the field data
itself? Java gives you a number of different ways to represent common datatypes, such
as strings, numbers, dates, and bit flags. Depending on which
representation you choose, the overhead costs can vary quite a bit. 
These costs, hidden in the implementation, are not obvious, and can be
surprisingly high.
In this chapter, we look at the costs of different representations for the most 
commmon datatypes.

\section{Character Strings}
\code{Strings} are the most common non-trivial data type found in Java
programs. They are the single largest consumer of memory in most applications,
typically taking up 40-50\% of the heap. We discuss when to use a Java \class{String} to
represent data, and when not to.

%\subsection{External vs. Internal Datatype Forms}
\subsection{Scalars vs. Character Strings}
Character strings are the universal data type, in that all data can be
represented in string form.  For example, I am now typing the integer 347 as a
string of characters in this paragraph, and it is stored in a file as a sequence
of characters. Similarly decimal numbers, dates, and boolean values can be
represented as character strings.
 
In Java programs, it's very common to see scalar data represented as instances
of the Java \class{String} class. This representation makes some sense if the
data is read in and/or written out as characters, since it avoids the
cost of conversion. However, there are several good reasons why it's better
to represent data as scalars whenever possible. First, if you need to perform
any kind of operations on the data, you will need to convert it to use
available datatype operators. If these conversions are performed
repeatedly, then there may be lots of temporaries generated needlessly.  Second,
representing data with specific data types leads to better type checking to avoid bugs. 
Third, specific data types provide a simple form of documentation.
Last but not least, the memory overhead of a string representation is much
higher than the overhead of scalars and even of boxed forms.

\begin{table}
  \centering
\begin{tabular}{llr} \toprule \toprule
& Example & Size \\ \midrule \midrule
integer & int anint = 47; & 4 \\
\midrule
& Integer anint = new Integer(47); & 20 (4+16)  \\
\midrule
& String anint = new String(``47''); & 44 (4+40) \\
\midrule
\midrule
boolean & boolean abool = true; & 1\\
\midrule
& Boolean abool = new Boolean(true): & 20 (4+16) \\
\midrule
& String abool = new String(``T''); & 44 (4+40) \\
\midrule \midrule
enumerated type & enum Gender \{MASCULINE, FEMININE, NEUTER\}; &\\
& Gender agender = MASCULINE; & 4 \\
\midrule
& String agender = new String(``masculine''); & 60 (4+56) \\
\bottomrule \bottomrule
\end{tabular}
\caption{The cost of different ways to represent an integer, a boolean, and an
enumerated type. The size column shows both the field size and the cost of
additional delegated objects.}
\label{tab:scalar-data-sizes}
\end{table}

Table~\ref{tab:scalar-data-sizes} shows three examples of the cost of different
representations of the same value. In the first example, an integer 47 can be
represented as a 4-byte scalar field, a boxed scalar, or a Java \class{String}. 
The \class{String} is by far the costliest representation, requiring 11 times
the memory of the scalar representation. It has a bloat factor of 95\%.
The effect is similar in the other two examples, a boolean and an enumerated
type. The blowup in memory cost for the \class{String} representation is a
factor of 44 and 15, respectively. In Java, \class{Strings} are a very expensive way to
represent scalar values, much more so than in many other languages.

\subsection{StringBuffer vs. String}
Java provides a few different datatypes for character strings, each one
addressing a common use case. \code{Strings} are immutable, meant for
string data that never changes once initialized. \code{StringBuffers} and
\code{StringBuilders}, on the other hand, are for string data that continues to
be updated over time.

Using long-lived \class{StringBuffers} to store stable character strings 
can waste memory\footnote{This discussion
applies equally to \class{StringBuffer} and \class{StringBuilder}.}. That's
because \class{StringBuffers} were designed for building string data over time. They
allocate excess capacity to reduce the time needed for reallocating the
character array and copying the data.  \class{StringBuffers} will usually
have significant empty space, since they double in size whenever they need to be reallocated. 
Typically, after a string is built up in the \class{StringBuffer}, it is stable, at which point
it should be converted to a \class{String}, so that the \class{StringBuffer} can be
garbage collected. Using a \class{StringBuffer} to facilitate
building a \class{String} is fine, but it should only be used as a temporary
in this case.

\section{Bit Flags}
\label{sec:bit-flags}

A value that can be represented by a single bit seems pretty innocuous from a
memory point of view. However, when an entity contains a number of bit
fields, then it's worth looking at the cost implications of
the different ways you can represent these fields. As an example, let's
consider a business, open seven days a week, where employees are 
assigned to work on different fixed days.  We compare three different ways of representing
work days as bit flags in an employee record.
 
First, you can represent bit flags as boolean fields in an object. For example
employee working days can be directly stored in an employee record:
\begin{shortlisting}

    public class Employee {
    	boolean monday, tuesday, wednesday, thursday, friday, saturday, sunday;
    	
    	public void setWorkMonday(boolean flag) {
    		monday = flag;
    	}
    	..
    }
    
\end{shortlisting}

Each boolean field takes one byte, so each employee requires at least seven
bytes to store workday information. 

Alternatively, you can represent bit flags very compactly as actual bits, and
manipulate the bits indirectly via accessor and update methods. There is more
code involved, but it is isolated in these few methods. Seven days of the week can be stored as
bits in a single \code{byte} field:

\begin{shortlisting}
	public class Employee {
	
		public final static byte Monday = 0x01;
		public final static byte Tuesday = 0x02;
		public final static byte Wednesday = 0x04;
		public final static byte Thursday = 0x08;
		public final static byte Friday = 0x10;
		public final static byte Saturday = 0x20;
		public final static byte Sunday = 0x40;
		
		private byte workdays;
		
		public void setWorkMonday(boolean flag) {
			if (flag) {
				workdays = (byte)(workdays | Monday);
			} else {
				workdays = (byte)(workdays & ~Monday);
			}
		}
		..
   }
		       
\end{shortlisting}

While compact, these representations are awkward from a coding and
stylistic point of view. A better practice is to represent each bit flag
as a constant in an \code{enum} type, and to store the values of the group
of flags as an \code{EnumSet}.

\begin{shortlisting}

    public class Employee {
 
		public enum Day {MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY};
    	
    	private EnumSet<Day> workdays = EnumSet.noneOf(Day.class);
    
   	 	public void setWorkday(Day day) {
			if (flag) {
				workdays.add(day);
			} else {
				workdays.remove(day);
			}
		}
	}
    
    
\end{shortlisting}

Since an \class{EnumSet} is an object, this representation is going to
cost more, in part because of delegation. On the \oracle \jre, the
storage is pretty well optimized. If the underlying \code{enum} type has up to 64 constants,
then an \class{EnumSet} requires just a single object of size 24 bytes. If
the \code{enum} type has more than 64 constants, then an \class{EnumSet} requires
two objects, a wrapper plus a \class{long[]} array. The total cost in that case
is 40 bytes plus enough 8-byte \class{longs} in the array to hold the bit flags. 
In our example, the cost of storing workdays is 28 bytes per employee:
4 bytes for the reference field and 24 bytes for the \class{EnumSet}. 
This is considerably more expensive than storing the bit flags as either bits or
booleans. That is, unless your entity has a large number of bit flags
that form a natural grouping. The crossover point in cost, versus a boolean
representation, is 28 flags\footnote{On a \jre that doesn't pack \code{boolean}
fields tightly, such as the \ibm \jre, the crossover point is much lower.}.

The \code{EnumSet} representation allows for sharing in some cases, which can 
reduce the cost considerably. Suppose
that there are 1000 employees. The cost of storing the workdays for these
employees using an \class{EnumSet} is 28,000 bytes. 
Now suppose 900 employees work Monday
through Friday. These employees can share an \class{EnumSet} representing
these normal working days, reducing the cost to 6,424 bytes. See \autoref{chapter:sharing-immutable-data}
for more on sharing data.

\begin{table}
  \centering
\begin{tabular}{llr} \toprule \toprule
Representation & Size \\ \midrule \midrule
bits in a byte & 1 \\
\midrule
boolean fields & 7 \\
\midrule
\code{EnumSet} & 28 (4+24) \\
\bottomrule \bottomrule
\end{tabular}
\caption{The cost of different ways of storing the seven bit flags in our
example, representing days of the week.
The size column shows both the field size and the cost of additional delegated objects.}
\label{tab:bit-flag-sizes}
\end{table}


\section{Dates}

Dates are very common in applications, but representing a date as a data type
can be complex. The complexity comes from the need to represent
universal time  and support conversions, arithmetic operations, and external
representations. In Java, there are different ways of representing times and
dates, and as usual, the more functionality you want, the more memory the
representation takes up.

The simplest and most compact way is to represent a time and date is as a
\code{long} integer:
\begin{shortlisting}
    long timeNow = System.currentTimeMillis();
\end{shortlisting}
The method call \code{System.currentTimeMillis()} returns the current 
date and time in milliseconds since January 1, 1970.  This representation is
perfect for timestamping, performance timings, and relative time
comparisons, however, it is clearly limited.  

For more functionality, you can use the \class{java.util.Date} class:
\begin{shortlisting}
    Date date = new Date();
\end{shortlisting}
This creates a relatively small object (24 bytes) that stores the current date
and time in milliseconds since January 1, 1970. The class \class{Date} itself
supports little other functionality, since most of its original methods have
been deprecated. You can print a \class{Date} object using the default
\code{toString} function. Interestingly, printing a \class{Date} has the funny
side effect of creating another object inside the \class{Date} object, which
doesn't go away!

So how do you get around this lack of functionality?
Because of the semantic richness of dates, Java provides other classes that
support various calendar functions, that operate on \class{Date} objects. For
example, \class{SimpleDateFormat} will print a \class{Date} according to a
specified format:
\begin{shortlisting}
    SimpleDateFormat dateFormat =  new SimpleDateFormat("dd/MM/yy"); 
    System.out.println(dateFormat.format(new Date())); 
\end{shortlisting}

For other date-related functions, you can use 
\class{GregorianCalendar}, which implements the very rich \class{Calendar}
interface and serves as a wrapper for \class{Date}:
\begin{shortlisting}

	GregorianCalendar calendar = new GregorianCalendar();
    Date now = calendar.getTime();
    int year       = calendar.get(Calendar.YEAR);
	int month      = calendar.get(Calendar.MONTH); 
	calendar.add(Calendar.MONTH, 3); 
	..
    
\end{shortlisting}

Now we have functionality, but at what cost? It turns out that a
\class{GregorianCalendar}, created with the default constructor requires six
objects, totalling 424 bytes. This doesn't include the many temporaries
thrown off during the initialization process. This means that if you need to
create many dates in your application, you should not store them as
\class{GregorianCalendars}. Instead, you should store your dates as \class{Date}
objects, and use just one or two instances of a \class{GregorianCalendar} for
operating on the dates:

\begin{shortlisting}
     static calendar = new GregorianCalendar();
     ..
	 Date now = calendar.getTime();
	 calendar.setTime(now);   // a single instance of a 
\end{shortlisting}

\section{BigInteger and BigDecimal}

It is rare that an integer is too big to be represented as an \class{int} or
\class{long}. However, there are rare occasions when a  \class{BigInteger} is
needed. For example, for example, the largest prime
just discovered is over 17 million digits long.
A \class{BigInteger} provides 
arbitrary-precison integer arithmetic functions, which exactly mimics the
functions of the standard integer. 
A \class{BigInteger} is immutable and almost always requires two objects (a
\class{BigInteger} plus an \class{int[]}), for a minimum of 48 bytes total.  The
cost can be more, depending on the number of digits.  The formula for the total size is 
44 + 4*(number of ints needed to represent the integer). 
Because of the cost, unless you need the extra digits, you should just use an integer or long.

Like \class{BigInteger}, the Java class \class{BigDecimal} performs
arbitrary-precision floating point arithmetic. Primarily,
\class{BigDecimals} are important for accounting and financial applications that
involve currency, where precision and rounding accuracy are critical. With \class{BigDecimals},
you can set both the scale, which is the number of digits to the right of the
decimal point, and the rounding method. How to do this is beyond our scope and
covered elsewhere\footnote{do we really need it??}, since our focus is on the
memory cost of the representation.

\class{BigDecimal} has two forms: a compact form and an
inflated form. Most of the time, \class{BigDecimal} uses the compact form,
which is a single 32-byte object that can store a number whose significand's
absolute value is less than or equal to \code{Long.MAX\_VALUE}.
All 18-digit decimal numbers will fit in that, and some 19-digit.  Bigger than
that, the inflated form is required. In the inflated form, \class{BigDecimal}
delegates the storage of the significand to a \class{BigInteger}, which almost always means two additional
objects, bringing the total for BigDecimal to 80 bytes at a
minimum.  

Unfortunately, sometimes a \class{BigDecimal} will become inflated,
since certain arithmetic methods will cause a \class{BigDecimal} to switch to its inflated form in order to perform the operation, and once inflated,
there's no switching back.  The cases are too numerous to predict, so if there's
a concern it's best to look at the heap and see what happens based on actual usage in the 
application.

Similarly, calling \code{toString()} on a \class{BigDecimal} causes it to
save its string representation, in case it is needed again.
This is another example of a performance optimization that 
costs space, built into the library.  This operation adds an extra two objects
retained with the \class{BigDecimal}. 

In summary, a \class{BigDecimal} will take one
object under most circumstances, but can take up to five. Since it is hard to
predict, you just have to beware.

\section{Summary} 

There are common data types just beyond simple primitives that can
take up a lot of space.  These include character strings, bit sets, dates, and
arbitrary-precision numeric data. This chapter shows the costs of various
representations and what the trade-offs are. Not surprisingly, the cost varies
according to functionality, and the main lessor is not to use expensive
representations unless you need the functionality.

\begin{itemize}
  \item  Don't use \class{String} to store data that can be natuarlly
  represented in a more compact data form, such as integer or boolean.
  \item Storing strings in \class{StringBuffers} can waste a lot of space
  if they are sized much bigger than the data they store.
  \item Even simple bit flags can cause bloat. If you generate lots of objects
  with bitflags, you should make sure you choose the most efficient
  representation.
  \item Beware of storing dates as \class{GregorianCalendars}.  A
  \class{GregorianCalendar} should only be used and reused as a converter
  object, to perform operations on \class{Dates}.
  \item \class{BigInteger} and \class{BigDecimal} provide arbitrary precision
  arithmetic on integers and decimals, and are needed when this functionality is
  needed. Otherwise, using them just consume a lot of space and time.
\end{itemize}









