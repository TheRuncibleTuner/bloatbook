\chapter{Representing Field Values}
\label{chapter:representing-values}

So far, we have been concerned with the wasteful overhead that results from
data representation. But what about the data itself?
Java gives you a number of different ways to represent common datatypes, such
as strings, numbers, dates, and bit flags. Depending on which
representation you choose, the overhead costs can vary quite a bit. 
These costs, hidden in the implementation, are not obvious, and can be
surprisingly high.
In this chapter, we look at the costs of different representations for the most 
commmon datatypes.

\section{Character Strings}
Strings are the most common non-trivial datatype found in Java programs. We
discuss when to represent data as a Java \class{String}, and when not to.
\paragraph{External vs. Internal Datatype forms Forms}
TOWRITE:
- It's very common to represent scalar data, such as int, boolean, or date, as
strings. There are many reasons why it's preferable to represent these as
scalars when you can. - give some reasons other than space (Effective Java makes
a good argument for this), such as availability of operators, type checking, self-documenting.  - in
addition, the overhead of a string representation is usually much higher than scalar forms. 
Much higher than even the boxed form as well.  Much higher
than in languages like C, as we saw in reference-chapter-on-datatypes.  Mention
bloat factor from one or two examples from the little table below.

- short table with 3 most common examples, comparing cost of scalar
vs. boxed form vs. String form.  Examples: int (95\%), boolean (using ``Y''
and ``N''), and enum. 

\paragraph{StringBuffer vs. String}

It is well-known that \class{StringBuffer} is more efficient than
\class{String} for performing string concatenation. Since \class{String}s are
immutable, concatenating \class{String}s involves allocating a temporary
\code{char} array, copying the \class{String}s into it, and then constructing
a result \class{String}. A \class{StringBuffer}, on the other hand, is mutable.
If the \class{StringBuffer} capacity is sufficient, then \class{String}s
can be concatenated by simply appending them to the \class{StringBuffer}.

However, long-lived \class{StringBuffer}s can waste memory. Usually a
\class{StringBuffer} is 40\% empty space, since they double in size whenever
they need to be reallocated. Typically, after a string is built up in the
\class{StringBuffer}, it is stable, at which point it should be converted 
to a \class{String}, so that the \class{StringBuffer} can be
garbage collected. Using \class{StringBuffer}s to facilitate
building a \class{String} is fine, but they should be used only as temporaries.

\section{Representing Bit Flags}
\label{sec:bit-flags}
TOWRITE:
- Discuss/compare cost of three representations: a bunch of boolean fields, a
byte with bit flags that you manage yourself, EnumSet.

\section{Dates}
TOWRITE:
- Discuss/compare cost of three representations: Date vs. Calendar vs. time in
millis.  Advice on when each is appropriate.

\section{BigInteger and BigDecimal}
TOWRITE:
- Discuss need for these, and costs.  - Describe the number of objects in each
(I don't think we need a diagram). - Compare to long/double.
