\chapter{Representing Values}
\label{chapter:representing-values}

So far, we have been concerned with the wasteful overhead that results from
data representation. But what about the data itself?
Java gives you a number of different ways to represent common datatypes, such
as strings, numbers, dates, and bit flags. Depending on which
representation you choose, the overhead costs can vary quite a bit. 
These costs, hidden in the implementation, are not obvious, and can be
surprisingly high.
In this chapter, we look at the costs of different representations for the most 
commmon datatypes.

\section{Character Strings}
String is the most common non-trivial datatype found in Java programs. We
discuss when to use a Java \class{String} to represent data, and when not to.
\paragraph{External vs. Internal Datatype Forms}
Character strings are the universal data type, in that all data can be
represented in string form.  For example, I am now typing the integer 347 as a
string of characters in this paragraph, and it is stored in a file as a sequence
of characters. Similarly decimal numbers, dates, and boolean values can be
represented as character strings.
 
In Java programs, it's very common to see scalar data represented as instances
of the Java \class{String} class. This representation makes some sense if the
data is read in and/or written out as characters, since it avoids the
cost of conversion. However, there are several good reasons why it's better
to represent data as scalars whenever possible. First, if you need to perform
any kind of operations on the data, you will need to convert it to use
available datatype operators. If these conversions are performed
repeatedly, then there may be lots of temporaries generated needlessly.  Second,
representing data with specific data types leads to better type checking to avoid bugs. 
Finally, specific data types provide a simple form of documentation.
In addition, the overhead of a string representation is much higher than
the overhead of scalars and even of boxed forms.

\begin{table}
  \centering
\begin{tabular}{llr} \toprule \toprule
& Example & Size \\ \midrule \midrule
INTEGER & int anint = 47; & 4 \\
\midrule
& Integer anint = new Integer(47); & 4+16  \\
\midrule
& String anint = new String(``47''); & 4+48 \\
\midrule
\midrule
BOOLEAN & boolean abool = true; & 1\\
\midrule
& Boolean abool = new Boolean(true): & 4+16 \\
\midrule
& String abool = new String(``true''); & 4+48 \\
\midrule \midrule
ENUMERATION & enum Gender {MASCULINE, FEMININE, NEUTER}; &\\
& Gender aGender = MASCULINE; & 4 \\
\midrule
& String agender = new String(``masculine''); & 4+48 \\
\bottomrule \bottomrule
\end{tabular}
\caption{The cost of different ways to represent an integer, a boolean, and an
enumerated type. The size column shows both the field size and the cost of
additional delegated objects.}
\label{tab:data-sizes}
\end{table}

Table~\ref{tab:data-sizes} shows three examples of the cost of different
representations of the same value. (See Chapter~\ref{chapter.delegation} for
details on these costs.) In the first example, and integer 47 can be
represented as a 4 byte field, a boxed object, or a Java \class{String}. 
The \class{String} is by far the costliest representation, with a bloat factor of
96\%.  Similarly for the other two examples, a boolean and an enumeration type.
\class{String}s are simply a very expensive way to represent scalar values.

\paragraph{StringBuffer vs. String}

Common wisdom is that using \class{StringBuffer} is more efficient than
\class{String} for performing string concatenation. For example, a simple way
to create a concatenated string:
\begin{shortlisting}
	String str = "Beginning  " + "Middle " +  "End";
\end{shortlisting}
However, since \class{String}s are immutable, this code results in several
temporary \class{String}s being created, copied, and discarded.  It turns out
that the following code is more efficient:
\begin{shortlisting}
	StringBuffer str = new StringBuffer ("Beginning ");
	str.append("Middle ");
    str.append("End");
\end{shortlisting}
\class{String}s are immutable, concatenating \class{String}s involves allocating a temporary
\code{char} array, copying the \class{String}s into it, and then constructing
a result \class{String}. A \class{StringBuffer}, on the other hand, is mutable.

However, long-lived \class{StringBuffer}s can waste memory. Usually a
\class{StringBuffer} will have significant empty space, since they double in
size whenever they need to be reallocated. Typically, after a string is built up in the
\class{StringBuffer}, it is stable, at which point it should be converted 
to a \class{String}, so that the \class{StringBuffer} can be
garbage collected. Using \class{StringBuffer}s to facilitate
building a \class{String} is fine, but they should be used only as temporaries.

\section{Representing Bit Flags}
\label{sec:bit-flags}
TOWRITE:
- Discuss/compare cost of three representations: a bunch of boolean fields, a
byte with bit flags that you manage yourself, EnumSet.

\section{Dates}

While \textit{time} and \textit{date} are not primitive data types in most
programming languages, they are common and surprisingly complex enough to call
out. In Java, there are different ways of representing times and dates, and as
usual, the more functionality you want, the more memory the representation takes
up. We describe here three common representations.

The simplest and most compact way is to represent a time and date as a
\code{long} integer:
\begin{shortlisting}
    long timeNow = System.currentTimeMillis();
\end{shortlisting}
The method call \code{System.currentTimeMillis()} returns the current 
date and time in milliseconds since January 1st 1970.  This representation is
perfect for timestamping, performance timings, and relative time
comparisons, however, it is clearly limited. For example, sometimes you want the
representation to be an object for type safety, the ability to initializate it
to \code{null}, or the ability to store it in a a structure like a
\code{HashTable}, for example.

The simplest way to represent a time and date as an object is to use the
\class{java.util.Date} class:
\begin{shortlisting}
    Date date = new Date();
\end{shortlisting}
This creates a relatively small object (24 bytes) that stores the current date
and time in milliseconds since January 1, 1970. The class \class{Date} has
little other functionality, since most of its original methods have been
deprecated. It does implement the \class{Comparable} interface, which enables
date comparison. The main advantages of this representation over \code{long} are
those that come with being a typed object.



If you just need an object to hold a date, for instance as a property in a
simple domain model object, you can use the java.util.Date class.

Date is a total of 24 bytes, not 16.  That doesn't include the pointer:

long fastDate    8
Date cdate  4
header + alignment = 12 

This Date instance contains the current time as its date and time.
java.util.Date date = new java.util.Date();

long time = date.getTime(); 

java.util.Calendar -- has methods to do date and time arithmetic like adding a
day or
month to another date.
If you need to do date calculations like adding days or months to another date,
or check what weekday (monday, tuesday etc.) a given date is, or convert dates and times between time zones, use the java.util.Calendar Calendar -- can do calendar arithmetic -- add a day or
month to another date; convert between timezones, etc. - Discuss/compare cost of three representations:
Date vs. Calendar vs. time in millis.  Advice on when each is appropriate.

\section{BigInteger and BigDecimal}
TOWRITE:
- Discuss need for these, and costs.  - Describe the number of objects in each
(I don't think we need a diagram). - Compare to long/double.
