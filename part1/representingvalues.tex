\chapter{Representing Field Values}
\label{chapter:representing-values}

So far, we have been concerned with the wasteful overhead that can result when
modeling your entities as classes and fields. But what about the field data itself?
Java gives you a number of different ways to represent common datatypes, such
as strings, numbers, dates, and bit flags. Depending on which
representation you choose, the overhead costs can vary quite a bit. 
These costs, hidden in the implementation, are not obvious, and can be
surprisingly high.
In this chapter, we look at the costs of different representations for the most 
commmon datatypes.

\section{Character Strings}
String is the most common non-trivial datatype found in Java programs, and the single largest 
consumer of memory in most applications. We
discuss when to use a Java \class{String} to represent data, and when not to.
\paragraph{External vs. Internal Datatype Forms}
Character strings are the universal data type, in that all data can be
represented in string form.  For example, I am now typing the integer 347 as a
string of characters in this paragraph, and it is stored in a file as a sequence
of characters. Similarly decimal numbers, dates, and boolean values can be
represented as character strings.
 
In Java programs, it's very common to see scalar data represented as instances
of the Java \class{String} class. This representation makes some sense if the
data is read in and/or written out as characters, since it avoids the
cost of conversion. However, there are several good reasons why it's better
to represent data as scalars whenever possible. First, if you need to perform
any kind of operations on the data, you will need to convert it to use
available datatype operators. If these conversions are performed
repeatedly, then there may be lots of temporaries generated needlessly.  Second,
representing data with specific data types leads to better type checking to avoid bugs. 
Finally, specific data types provide a simple form of documentation.
In addition, the overhead of a string representation is much higher than
the overhead of scalars and even of boxed forms.

\begin{table}
  \centering
\begin{tabular}{llr} \toprule \toprule
& Example & Size \\ \midrule \midrule
integer & int anint = 47; & 4 \\
\midrule
& Integer anint = new Integer(47); & 20 (4+16)  \\
\midrule
& String anint = new String(``47''); & 52 (4+48) \\
\midrule
\midrule
boolean & boolean abool = true; & 1\\
\midrule
& Boolean abool = new Boolean(true): & 20 (4+16) \\
\midrule
& String abool = new String(``T''); & 52 (4+48) \\
\midrule \midrule
enumerated type & enum Gender \{MASCULINE, FEMININE, NEUTER\}; &\\
& Gender agender = MASCULINE; & 4 \\
\midrule
& String agender = new String(``masculine''); & 68 (4+64) \\
\bottomrule \bottomrule
\end{tabular}
\caption{The cost of different ways to represent an integer, a boolean, and an
enumerated type. The size column shows both the field size and the cost of
additional delegated objects.}
\label{tab:data-sizes}
\end{table}

Table~\ref{tab:data-sizes} shows three examples of the cost of different
representations of the same value. (See Chapter~\ref{chapter:delegation} for
details on these costs.) In the first example, an integer 47 can be
represented as a 4 byte field, a boxed object, or a Java \class{String}. 
The \class{String} is by far the costliest representation, with a bloat factor of
92\%, or 13 times the memory of the scalar representation.  Similarly for the other two examples, a
boolean and an enumerated type.
\class{String}s are simply a very expensive way to represent scalar values.

\paragraph{StringBuffer vs. String}

Common wisdom is that using \class{StringBuffer} is more efficient than
\class{String} for performing string concatenation. For example, a simple way
to create a concatenated string:
\begin{shortlisting}
	String str = "Beginning  " + "Middle " +  "End";
\end{shortlisting}
However, since \class{String}s are immutable, this code results in several
temporary \class{String}s being created, copied, and discarded.  It turns out
that the following code is more efficient:
\begin{shortlisting}
	StringBuffer str = new StringBuffer ("Beginning ");
	str.append("Middle ");
    str.append("End");
\end{shortlisting}
\class{String}s are immutable, concatenating \class{String}s involves allocating a temporary
\code{char} array, copying the \class{String}s into it, and then constructing
a result \class{String}. A \class{StringBuffer}, on the other hand, is mutable.

However, long-lived \class{StringBuffer}s can waste memory. Usually a
\class{StringBuffer} will have significant empty space, since they double in
size whenever they need to be reallocated. Typically, after a string is built up in the
\class{StringBuffer}, it is stable, at which point it should be converted 
to a \class{String}, so that the \class{StringBuffer} can be
garbage collected. Using \class{StringBuffer}s to facilitate
building a \class{String} is fine, but they should be used only as temporaries.

\section{Representing Bit Flags}
\label{sec:bit-flags}

A value that can be represented by a single bit seems pretty innocuous from a
memory point of view. However, there are different ways to represent bit flags
in Java, and so it's worth devoting a section to the cost implications of
bit flags. As an example, let's consider a business, open seven days a
week, where employees are assigned to work on different fixed days.  We compare three
different ways of representing work days as bit flags in an employee record.
 
First, you can represent bit flags as boolean fields in an object. For example
employee working days can be directly stored in an employee record:
\begin{shortlisting}

    public class Employee {
    	boolean monday, tuesday, wednesday, thursday, friday, saturday, sunday;
    	
    	public void setWorkMonday(boolean flag) {
    		monday = flag;
    	}
    	..
    }
    
\end{shortlisting}
Each boolean field takes one byte, so each employee contains at least seven
bytes to store workday information. 

Alternatively, you can represent bit flags very compactly as actual bits, and
manipulate the bits via accessor methods. There is more code involved,
but it is isolated in these few methods. Seven days of the week can be stored as
bits in a single byte field:

\begin{shortlisting}
	class Employee {
	
		public final static byte Monday = 0x01;
		public final static byte Tuesday = 0x02;
		public final static byte Wednesday = 0x04;
		public final static byte Thursday = 0x08;
		public final static byte Friday = 0x10;
		public final static byte Saturday = 0x20;
		public final static byte Sunday = 0x40;
		
		private byte workdays;
		
		public void setWorkMonday(boolean flag) {
			if (flag) {
				workdays = (byte)(workdays | Monday);
			} else {
				workdays = (byte)(workdays & ~Monday);
			}
		}
		..
   }
		       
\end{shortlisting}

While compact, these representations are awkward from a coding and
stylistic point of view. A better practice is to represent bit flag values
using an enumerated type, and to represent bit flag fields using Java
\class{EnumSet}s:
\begin{shortlisting}

    class Employee {
 
		public enum Day {MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY};
    	
    	private EnumSet<Day> workdays = EnumSet.noneOf(Day.class);
    
   	 	public void setWorkday(Day day) {
			if (flag) {
				workdays.add(day);
			} else {
				workdays.remove(day);
			}
		}
	}
    
    
\end{shortlisting}

Since an \class{EnumSet} is an object, this representation is going to
cost more because of delegation. On the Sun JVM, the storage is pretty
well optimized. If the underlying Enum type has less than 64 elements, then an
\class{EnumSet} is represented by one object of size 24 bytes. If the
\code{enum} type has more than 64 elements, then an \class{EnumSet} is two objects, a wrapper plus a
\class{long[]} array. The total cost is 40 bytes plus enough 8-byte
\class{long}s in the array to hold the bit flags. In our example, the cost of storing workdays is 28 bytes per employee:
4 bytes for the reference field and 24 bytes for the \class{EnumSet}. This is considerably
more expensive than storing the bit flags as either bits or booleans. 

When possible, sharing can optimize the cost of 
 \class{EnumSet}s considerably. Suppose
that there are 1000 employees. The cost of storing the workdays for these
employees using an \class{EnumSet} is 28,000 bytes. 
Now suppose 900 employees work Monday
through Friday. These employees can share an \class{EnumSet} representing
these normal working days, reducing the cost to 6,424 bytes.  See \autoref{chapter:sharing-immutable-data}
for more on sharing data.


\section{Dates}

Dates are very common in applications, but representing a date as a data type
can be complex. The complexity comes from the need to represent
universal time  and support conversions, arithmetic operations, and external
representations. In Java, there are different ways of representing times and
dates, and as usual, the more functionality you want, the more memory the
representation takes up.

The simplest and most compact way is to represent a time and date is as a
\code{long} integer:
\begin{shortlisting}
    long timeNow = System.currentTimeMillis();
\end{shortlisting}
The method call \code{System.currentTimeMillis()} returns the current 
date and time in milliseconds since January 1, 1970.  This representation is
perfect for timestamping, performance timings, and relative time
comparisons, however, it is clearly limited.  

For more functionality, you can use the \class{java.util.Date} class:
\begin{shortlisting}
    Date date = new Date();
\end{shortlisting}
This creates a relatively small object (24 bytes) that stores the current date
and time in milliseconds since January 1, 1970. The class \class{Date} itself
supports little other functionality, since most of its original methods have
been deprecated. You can print a \class{Date} object using the default
\method{toString} function. Interestingly, printing a \class{Date} has the funny
side effect of creating another object inside the \class{Date} object, which
doesn't go away!

So how do you get around this lack of functionality?
Because of the semantic richness of dates, Java provides other classes that
support various calendar functions, that operate on \class{Date} objects. For
example, \class{SimpleDateFormat} will print a \class{Date} according to a
specified format:
\begin{shortlisting}
    SimpleDateFormat dateFormat =  new SimpleDateFormat("dd/MM/yy"); 
    System.out.println(dateFormat.format(new Date())); 
\end{shortlisting}

For other date-related functions, you can use 
\class{GregorianCalendar}, which implements the very rich \class{Calendar}
interface and serves as a wrapper for \class{Date}:
\begin{shortlisting}

	GregorianCalendar calendar = new GregorianCalendar();
    Date now = calendar.getTime();
    int year       = calendar.get(Calendar.YEAR);
	int month      = calendar.get(Calendar.MONTH); 
	calendar.add(Calendar.MONTH, 3); 
	..
    
\end{shortlisting}

Now we have functionality, but at what cost? It turns out that a
\class{GregorianCalendar}, created with the default constructor requires six
objects, totalling 424 bytes. This doesn't include the many temporaries
thrown off during the initialization process. This means that if you need to
create many dates in your application, you should not store them as
\class{GregorianCalendars}. Instead, you should store your dates as \class{Date}
objects, and use just one or two instances of a \class{GregorianCalendar} for
operating on the dates:
\begin{shortlisting}
     static calendar = new GregorianCalendar();
     ..
	 Date now = calendar.getTime();
	 calendar.setTime(now);   // a single instance of a 


\end{shortlisting}

\section{BigInteger and BigDecimal}
TOWRITE:
- Discuss need for these, and costs.  - Describe the number of objects in each
(I don't think we need a diagram). - Compare to long/double.
