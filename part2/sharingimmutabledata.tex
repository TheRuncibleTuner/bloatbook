\chapter{Sharing Immutable Data}

So far, we have been concerned with the overhead of a representation.
But what about the data itself? If you examine any Java heap, you will
find that a
large amount of the data is duplicated. At one extreme, 
there may be thousands of copies of the same boxed
integers, especially 0 and 1. At the other extreme, there may be many identical
copies of small data structures that have the same shape and data values.
And, of course, duplicate strings are extremely common.
This chapter describes various
opportunities and techniques that you can use for sharing data to avoid
duplication, including a few low-level mechanisms that Java provides.

\section{Sharing String Literals}
\label{literals}

The JVM stores string literals in a \emph{string constant pool} when its class
is loaded. However, when a new string is created during execution, it is stored
in the heap, without any check for duplication. String duplication is one of the
most common and expensive sources of bloat. As we have seen, even small
strings incur a large overhead. Fortunately, it is not hard to eliminate string
duplication. One technique is to represent strings as static literals whenever possible, 
and avoid dynamic
creation.

 As an example, suppose you are
reading in property name-value pairs from files into tables:
\begin{shortlisting}
class ConfigurationProperties {
    ..
	void handleNextEntry() {
		String propertyName = getNextString();
		String propertyValue = getNextString();
		propertyMap.put(propertyName, propertyValue);
	}
}
\end{shortlisting}
The compiler cannot tell whether any of the strings read in are duplicates. If 
there are just a few distinct property names in all of the input pairs, these
property names will be duplicated many times in the heap.

However, if you know in advance what all of the property names are, then you can
define them in advance as static strings, which are shared among the
entries of \code{propertyMap}.
\begin{shortlisting}
class PropertyNames {
	public static String numberOfUnits = ``NUM_UNITS'';
	public static String minWidgets = ``MIN_WIDGETS'';
	..
}

class ConfigurationWithStaticProperties {
    void handleNextEntry() {
       String propertyName = getNextPropertyName(); 
       String propertyValue = getNextString();
       propertyMap.put(propertyName, propertyValue);
    }
}
\end{shortlisting}
One copy of each property name is stored in the string constant pool, and there
are no duplicates in the heap. Alternatively, you could use an enumeration type,
instead of string literals for the property names, perhaps a better stylistic
choice.

A common
 mistake is to create a new string when you don't have to. For example, in the
following code, there is no need to create new strings from literals.
\begin{shortlisting}
class PropertyNames {
	public static String numberOfUnits = new String(``NUM_UNITS'');
	public static String minWidgets = new String(``MIN_WIDGETS'');
	..
}
\end{shortlisting}
Even though the standard library is smart enough not to duplicate the
character arrays, this code still creates redundant \code{String} objects in
the heap.

Using static strings to eliminate dulication is only possible when the string
values are know in advance. 
Section~\ref{sec:sharing-poos} introduces the notion of a sharing pool for
sharing dynamic data. Section~\ref{sec:java-mechanisms} describes how to use the
Java internal string pool to eliminate duplication under the covers.

\section{Sharing Pools}
\label{sec:sharing-pools}

Suppose your application creates a lot of duplicate data, but you don't
know the data values before execution. 
You can still avoid duplication by using a \emph{sharing pool}, as shown in 
Figure~\ref{fig:sharing-pool}. In Figure~\ref{fig:sharing-pool}(a), objects
A and B point to identical data structures.
Figure~\ref{fig:sharing-pool} shows objects A and B sharing the same data
structure, which is stored in a sharing pool.

\callout{callout:sharing-pool}{Sharing Pool}{
A \emph{sharing pool} is a centralized structure that stores 
canonical data values that would otherwise be replicated in many objects.
A sharing pool itself is usually a some sort of hash table, although it
could be implemented in other ways. 
}

There are several issues that you need to be aware of before using a sharing
pool.
\paragraph{Shared objects must be immutable.}

\paragraph{Sharing objects changes identity semantics.}

\paragraph{Sharing pools should not be used if there is limited sharing.}

\paragraph{Shared objects should be garbage collected.}



\section{Java Mechanisms for Sharing Data}
\label{sec:java-mechanisms}

The following
pseudo-code shows what happens under the covers when you want to create or use a
shared object:

\begin{shortlisting}
    share(sharedObject) { 
        if (sharingPool contains a copy of sharedObject) {
        	return copy of sharedObject;  
        } else {
            add sharedObject to sharingPool;
            return sharedObject;
        }
    }
\end{shortlisting}

The JVM stores string literals in a \emph{string constant pool}. Since strings
are immutable, it is safe for the JVM to eliminate duplicates, and keep just
one copy of each literal string. In the following code, the JVM stores two
strings, \code{``Harry''} and \code{``Tom''} in the constant pool, and
\code{name1} and \code{name3} share the string \code{``Harry''}.
\begin{shortlisting}
class BunchOfStrings {
	String name1 = ``Harry'';
	String name2 = ``Tom'';
	String name3 = ``Harry'';
}
\end{shortlisting}

 You can do this type of storage
optimization, which replaces run-time strings by compile-time literals, 
provided you know what the strings are in advance at
compile-time. 

As described in the next few sections, Java makes it easy to
share strings and \code{Integers}. For sharing other kinds of data, you have to
implement your own sharing pool. However, in all cases, there are a several
issues that you should be aware of.


\section{Sharing Dynamic Strings}

Suppose your application creates a lot of duplicate strings, but you don't
know what they are before the application runs. You still have an opportunity
to reduce duplication by using a dynamic string pool to share strings.
%A solution to this problem is to use a 
%sharing pool to avoid creating duplicate strings. 
%A sharing pool is a centralized structure that stores 
%canonical data values that would otherwise be replicated in many objects.
%Before storing a 
%To use a sharing pool, before storing a new
%\class{String}, first check the pool to see if it is already there. If it is,
%reuse it; otherwise, add the new string to the pool. 
%One catch is that if you end up adding many strings to
%the pool that are never reused, then you will waste memory, since the pool
%structure itself has overhead. So you need to have a good idea
%which strings are likely to have duplicate values.
%%As an example, suppose you need to load configuration information from a file,
%%where they are stored as a long list of tables that map property names to
%value. Here is code to read and store a single table entry.
%The names come from a small set
%of 16 distinct names. The values are strings come from
%a set of strings unknown at development time, but a set that is small in size;
%there aren't going to be many distinct values, but you are unwilling or unable
%to nail them down at compile time. How can these maps be stored in a memory
%efficient way?
%Without any special effort, each instance of this kind of configuration map
%would store the some subset of same 16 key strings. Furthermore, each map would
%store duplicates of the values. The following code snippet has those two
%aspects of duplication:
Fortunately, 
 Java provides a built-in string pool, maintained in the JVM internal \emph{perm 
space}. The mechanism for using the string pool is called
\emph{interning}\index. In the configuration property example from
seciton~\ref{literals}, property
name duplication was eliminated using an enumeration type, but not
property value duplication. Suppose there are many duplicated values, but you
don't know them at compile-time. The following code interns the property value
strings read in, which eliminates duplication during execution.
\begin{shortlisting}
enum PropertyName = {...};
 
 class ConfigurationPropertiesWithInterning {
    void handleNextEntry() {
       PropertyName propertyName = getNextPropertyName(); 
       String propertyValue = getNextString().intern();
       propertyMap.put(propertyName, propertyValue);
    }
}
\end{shortlisting}

By calling \code{intern} on each newly created string,
if the string has not already been saved, it is added to the internal string
pool, and a pointer to it is returned. Otherwise, the new string is a
duplicate, and a previously saved string is returned.

There are semantic implications of interning
strings that you should be aware of. Under the covers, the JVM is storing unique
string values as sharable objects. But a string consists of two objects,
a \class{String} and a \code{char} array, and it makes a difference which of
these the JVM makes sharable. For example, consider the code: 
\begin{shortlisting}
    String name1 = getNextString();
    String name2 = getNextString();
    System.out.println(name1 == name2);
    System.out.println(name1.equals(name2));
\end{shortlisting}
If \code{name1} and
\code{name2} both store the same string value, then the first print statement
will print \code{false}, and the second print statement will print \code{true}.
This is because  \code{equals} compares the \code{char} arrays of the two
strings, while \code{==} compares the identities. Compare this with code that
interns these strings:
\begin{shortlisting}
    String name1 = getNextString().intern();
    String name2 = getNextString().intern();
    System.out.println(name1 == name2);
    System.out.println(name1.equals(name2));
\end{shortlisting}
In this case,  both print statements
print \code{true}. This is because when you intern strings with the same
value, the \class{String} objects themselves are shared. Therefore, if you are
interning strings, you need to be careful and avoid depending on \code{==} for identity semantics. 
If you want the value of two strings to be
equal \emph{only if} they are the same object, then don't use interning.
If your program just uses \code{equals} for string comparison, you are safe.

The JVM implements interning in native code, not at the Java level, and stores
interned strings in \emph{perm space}, not the heap. If perm space
fills up, you will get an error message like: \code{java.lang.OutOfMemoryError:
PermGen Space}. Its size can be increased by setting the PermSize and
MaxPermSize command line arguments. To avoid memory leaks, the JVM performs
garbage collection on interned strings. 

Interned strings are stored by the JVM in a table,
 so there is additional memory overhead for each interned string. 
Therefore, you need to be careful to intern strings only when you know that
 there would be expensive duplication otherwise. Indiscrimately interning
 strings wastes memory. Even though this
 memory is not part of the heap, native memory costs add up also.
 
 %    * Literal strings within the same class in the same package represent
%     references to the same String object. * Literal strings within different
 %    classes in the same package represent references to the same String
%     object. * Literal strings within different classes in different packages
 %    likewise represent references to the same String object. * Strings
 %    computed by constant expressions are computed at compile time and then
   %  treated as if they were literals. * Strings computed by concatenation at
    % run time are newly created and therefore distinct.
 

\paragraph{Sharing Scalars}
Also, recently the boxed scalars, I think this started in 1.5, maybe 1.6, that they have these 
methods called valueOf, where they will do some sharing for you. So if you think you will have 
a lot of copies of a Capital Integer, for example, they won’t share all of them, not like intern,
 where they always share this thing. They allocate a cache at the beginning of very commonly used 
 integers, commonly used across all applications, so it’s not dynamically determined. 
 Somebody at compile time has decided that the numbers from -100 to 100 are likely to be used 
 a lot. So if you happen to hit one of those, you’re going to get a shared one. If you don’t, 
 you’ll get a new Cap Integer or Float, or whatever you are sharing here. So you have to be  
 a little careful using this. You definitely can’t assume that you can use ==. 
 Because sometimes you are going to get objects that are shared, and sometimes you are going to 
 get …  So this is sort of a funny mechanism here.


\section{Wrong Data Container}
\section{Sharing Strings}

So what they were doing there, was they were saving both a binary version, and an ASCII 
formatted version of the same field, and they were doing that for a lot of fields. 
And since this was a delegated design, this was multiplied everywhere. So it really added up.  
We looked at the field cost, last time, in the actual objects making up the profile, but the 
other thing that is super common is that they were pointing to Strings, actually storing the data, 
and the actual cost of the Strings was pretty high. So the naïve view, especially 
if you are used to languages like C, is that, what’s a couple of characters?  
I’ll just store “Y” or “N”, what’s the big deal of storing one or two characters. 
But as we saw, looking inside the string, the health ratio for something like Y or an N, 
a single character, is 48:1. It takes about 44 bytes to store that string, plus the pointer 
to get there. In some cases these were either constant, or there were things that have just a 
few values. I think it just had three values, where every single record had both an int, or a 
short, and had the pointer to a string, which said Y or N.  This is a super common problem, 
is duplicating data that has a high overhead in its representation. That combination is all over 
the place, and Strings is the big culprit. They had another field like that. It was a policy 
threshold, and it was a constant every single record had this 10\% in it. And
they had the number 10\%, and a pointer to a string “10\%”, and a pointer to a
string, not sharing them. So certainly they would get a huge reduction just by sharing them. 
That’s one approach. It takes a little bit of machinery to build that. You can use String intern 
if you want.  I’ll talk about that. The other thing is just to compute the thing on the fly, 
assuming it’s something relatively easy. Actually these are 2 separate cases.
The 10\% you probably want to either share it or compute it on the fly somehow, because 
that’s probably a number that’s dynamically determined. Something like a Y or an N, 
I would guess is statically determined. That it has a small number of values that you can 
predict at compile time, and in that case you can have some final statics that are determined 
at compile time, and everyone can point to them. Pretty simple.



5.6 Redundant Objects

So we see the same pattern at kind of a higher level of not-sharing high overhead data, 
and this was from text analysis system being developed at research. This was a concordance, 
which was the center of an important data structure. This particular problem has been fixed. 
And there were multiple frameworks talking to each other, and one part of it building the 
concordance was relying on another framework to figure out the type of each word was. 
Each word in its context that was being indexed. And so in the concordance, even though the words, 
there were only 20 or 30 types total in this whole vocabulary, this whole classification system, 
there could be hundreds of thousands of these type data structures here, even though there are 
actually only 20 or 30 of them.  So this is the same thing here. Immutable data, that has a 
small number of values, that was highly duplicated, and it turned out the type itself had some 
fields in it, and it delegated its work to String, which of course is highly delegated, 
because it delegates its work to char array. So this was a fairly easy problem to fix by just 
introducing the shared immutable factory pattern to say I need a type object that matches this 
particular constant. If I have one already, then just give me back that otherwise, make a new one 
and put it in your pool, and we’ll share it. The one thing to keep in mind when implementing 
things like that, is to make sure you avoid any lifetime management issues, in particular, 
memory leaks.  You can also introduce a concurrency problem if you are not careful.


You can implement your own map using weak references. Go into tht pattern later. 
To make sure you avoid a memory leak. The downside of that is that there can be some pretty 
high per entry cost. Doing it yourself in Java.  Don’t know the native entry cost, but know 
the per entry in Java is pretty high. 



Common prefix???

5.7 Example: Caching Strings

Most bloated designs have multiple problems, as shown in this example.  (Quiz??)

Analysis of what’s wrong with this example.
So this was an example from one of the Lotus frameworks, from Sametime Gateway, and this 
was one piece of a session connection, and like all the other examples, it’s one piece of a 
data puzzle with other problems and other sources of costs. It was kind of a medium scale run. 
We saw that the biggest part of this data structure had sessions 110 of them. Each of them had 2 
StringBuffers, and that was taking the bulk of the space here.  We looked in to it, and they had 
quite a few different problems. We saw these StringBuffers sitting in the long lived heap, and 
thought, why would anyone store stringbuffers as permanent memory. Typically stringbuffers are 
used as temporaries. They have very aggressive storage allocation, kind of like the collectio
ns, 
with the thought in mind that you are going to grow them. You are going to be editing them.  
Typically, long-lived memory doesn’t have that problem. Typically, Strings in particular, you 
build them up, and then they are pretty stable. So it seems sort of strange. Usually 
StringBuffer
 is 40\% empty space, because it has a doubling algorithm for allocating them.
 The other strange thing was that they had 3 of them per session, and then there was the 
 question of whether they needed them at all. Turns out we looked at the code, and they had a 
 confluence of 3 different issues going on here. First of all, they had a somewhat delegated 
 design, and again, this was one of the consequences that delegated designs can have, where it 
 causes coding pattern to be duplicated. So in this case, for a completely different reason, 
 they had taken their session objects and split them into 3 parts. And they had some good design 
 reasons for doing that for some replication functionality they needed. But along with that, 
 they took a coding pattern that said that everytime they call toString on this thing for some 
 logging purpose, we’re going to save the contents of that String so that we don’t have to 
 recomputed it. That was really their main problem, that they didn’t realize how much space 
 they were 
taking 
up by saving this computation. And sometimes that’s indeed worth it. 
That you compute something and hold onto it.  In this case they realized they didn’t need to hold 
onto that much stuff. So in this case they had 3 problems. One is they were holding onto it, 
and it got multiplied by 3 because it was a delegated design. The second problem was they were 
holding onto it, and they may not need to. The third problem was they were going to hold onto it,
 
StringBuffer was the wrong thing to use.  In the end, they would have been better off 
trimming the StringBuffer, or just calling toString on it, and getting a shorter 
String out of it.




