\chapter{Reducing Object Bloat}

In many applications, the heap is mostly filled with instances of just a
few important classes.  You can increase scalability significantly by making these
classes as compact as possible. This chapter describes field usage
patterns that can be easily optimized for space, for example, fields that are
rarely needed, constant fields, and dependent fields. Simple refactoring of
these kinds of fields can sometimes result in big wins.
 

\section{Rarely Used Fields}

Chapter~\ref{chapter:delegation} presents examples where delegating fields
to another class increases memory cost. However, sometimes delegation can
actually save memory, if you don't have to allocate the delegated object all the
time.

As an example, consider an on-line store with millions of products. 
Most of the products are supplied by the parent company, but
sometimes the store sells products from another company:
\begin{shortlisting} 
class Product {
	String sku;
	String name;
	..
	String alternateSupplierName;
	String alternateSupplierAddress;
	String alternateSupplierSku;
}
\end{shortlisting}
When there is no alternate supplier, the last three fields
are never used. By moving these fields to a separate side class, you can
 save memory, provided the side object is allocated only when
it is actually needed. This is called \emph{lazy allocation}. Here are the 
refactored classes:

\begin{shortlisting} 
class Product {
	String sku;
	String name;
	.. 
	Supplier alternateSupplier;
}

class Supplier {
	String supplierName;
	String supplierAddress;
	String sku;
}
\end{shortlisting}
For products with no alternate supplier, eight bytes are saved per product,
since three fields are replaced by one. Of course, products with an alternate
supplier pay a delegation cost, including an extra pointer and object header.
An interesting question is how much total memory is actually saved? The
answer depends on the percentage of products that have an alternate supplier needing a
side object, which we'll call the \emph{fill rate}. The higher the fill rate, the less memory is 
saved. In fact, if the fill rate is too high, memory is wasted.

Figure~\ref{fig:fill-rate} shows the memory saved for different
fill rates, assuming three fields (12 bytes) are delegated. The most memory that can
be saved is 66\%, when the fill rate is
0\%. When the fill rate is 10\%, 50\% of memory is saved. 
When the fill rate is over 40\%, the memory saved is
negative, that is, memory is wasted. The lesson here is that if you aren't sure
what the fill rate is, then using delegation to save memory may end up
backfiring.
\begin{figure}
  \centering
 \includegraphics[width=.90\textwidth]{part2/Figures/chapter4/12-byte-graph.pdf}
 % \includegraphics{eight-char-string}
  \caption{This plot shows how much memory is saved or wasted by delegating 12
  bytes of memory to a side object. The x-axis is the fill rate, and the
  y-axis is the percent of memory saved.}
  \label{fig:fill-rate}
\end{figure}
In addition to the fill rate, the memory savings also depends on the
number of fields delegated. The more bytes delegated, the larger the memory
savings, assuming the same fill rate. Figure~\ref{fig:rarely-used} shows the memory
saved for different fill rates and different delegated-field sizes. Each
line represents a different delegated-field size. The bottom-most line
represents a delegated field size of 16 bytes, the next line represents 32 bytes, the next
represents 48 bytes, and so on, up to 144 bytes. As the delegated object size
increases, you can worry less about the fill rate. For example, if 32 bytes
are delegated, there is almost 90\% savings with a low fill rate, and some
memory savings with a fill rate up to 70\%. As the delegation size increases, 
the lines start to converge, since the fixed delegation cost becomes relatively
less important.
\begin{figure}
  \centering
 \includegraphics[width=.90\textwidth]{part2/Figures/chapter4/rarely-used.pdf}
 % \includegraphics{eight-char-string}
  \caption{This plot shows how much memory is saved or wasted for different
  delegate field sizes. The x-axis is the fill rate, and the y-axis is the
  percent of memory saved. Each line represents a different delegated size,
  starting from 16 bytes, going up to 144 bytes by increments of 16 bytes.}
  \label{fig:rarely-used}
\end{figure}

\callout{callout:rarely-used}{Delegation Cost Calculation}{
\index{Delegation Cost Calculation}
Assume the cost of a pointer is 4 bytes, and the cost of an object header is 8
bytes, and
\begin{eqnarray} 
B &=& the\ size\ in\ bytes\ of\ the\ delegated\ fields \nonumber \\
F &=& the\ fill\ rate\  \nonumber
\end{eqnarray}
The memory cost per object with the delegated
implementation is:
\begin{eqnarray}
D &=& F(B+8)+4 \nonumber
\end{eqnarray}
Note that every object pays a 4 byte pointer cost, and only $F$ of
the objects pay for the side object. The proportional improvement is:
\begin{eqnarray}
\frac{(B-D)}{B} &=& 1 - \frac{D}{B} \nonumber \\
&=& 1 - \frac{(F(B+8)+4)}{B} \nonumber
\end{eqnarray}
The following equation can be used to obtain the plots in
Figures~\ref{fig:fill-rate} and~\ref{fig:rarely-used}, for different values of
$B$:
\begin{eqnarray}
y &=& 100*(1 - \frac{\frac{x}{100}(B+8)+4}{B})
\end{eqnarray}
} 
A common error is to delegate rarely-used fields to a side class, but forget to
lazily allocate it, that is, always allocate a side object. 
In this case, instead of saving memory, you pay the full cost of delegation as well as 
the cost of unused fields. 
Lazy allocation
can be error-prone, since it may require testing whether the object exists at
every use. This complexity has to be weighed against potential memory
savings.

\section{Constant Fields}

Declaring a constant field \code{static} is a simple way to
save memory. Programmers usually remember to make constants like \emph{pi} 
static. There are other situations that are a bit more subtle, for example,
when a field is constant because of how it used in context of the application.

Returning to the product example, suppose that each product has a field
\code{catalog} that points to a store catalog.
If you know that there is always just one store catalog, then the field
\code{catalog} can be turned into a static, saving 4 bytes per product.

As a more elaborate example, suppose that every product belongs to a
category such as books, music, clothes, toys, etc, and 
 has a field pointing to a \class{Category} object.
These fields are clearly not the same across all products. However, suppose we
define
subclasses \class{Book}, \class{Music}, and \class{Clothing} of \class{Product}, 
and all instances of a subclass belong to the same category.  
Now the \code{category} field is the same for products in each subclass,
so it can be declared static:

\begin{shortlisting} 
class Book extends Product {
	static Category bookCategory; 	// points to the book category object  
	..
}

class Music extends Product {
	static Category musicCategory;  // points to the music category object
	..
}

class Clothing extends Product {
	static Category clothingCategory;  // points to the clothing category object
	.. 
}
\end{shortlisting}

Knowing the context of how objects are created and used, and how they relate to
other objects, is helpful in making these kinds of memory optimizations.


\section{Mutually Exclusive Fields}

Sometimes a class has fields that are never used at the same time, and therefore
they can share the same space. Unfortunately, Java does not have anything like
a union type, so to conflate several fields into one field, the fields have
to be of the same type. If the fields are not the same type, then a new type
must be created that is a generalization of the mutually exclusive field types.

For example, suppose that each women's clothing product has a size, and there
are different systems of women's sizes: xsmall-small-medium-large-xlarge,
numeric sizes, petite sizes, and large women's sizes. One way
to implement this is to introduce a field for each kind of size:
\begin{shortlisting}
class WomensClothing extends Product {
	static Category clothingCategory;  // points to the clothing category object
	..
	SMLSize     smlxSize;
	NumericSize  numSize;
	PetiteSize   petiteSize;
	WomensSize   womensSize; 
}
\end{shortlisting}
Each type is an enum class, such as:
\begin{shortlisting}
enum SMLSize {
	XSMALL, SMALL, MEDIUM, LARGE, XLARGE;
}

enum NumericSize {
	ZERO, TWO, FOUR, SIX, EIGHT, TEN, TWELVE, FOURTEEN, SIXTEEN;
}

enum PetiteSize {
    ZERO, TWO, FOUR, SIX, EIGHT, TEN, TWELVE, FOURTEEN, SIXTEEN;
}

enum WomensSize {
	ONEX, TWOX, THREEX, FOURX;
}
\end{shortlisting}
These four size fields are all mutually exclusive --- a clothing item cannot
have both a petite size and a women's size, for example. Therefore, you can
replace these fields by one field, provided that the four enum types are
combined into one enum type:
\begin{shortlisting}
class Clothing extends Product {
	static Category clothingCategory;  // points to the clothing category object
	..
	ClothingSize     size; 
}

enum ClothingSize {
	XSMALL, SMALL, MEDIUM, LARGE, XLARGE, 
	ZERO, TWO, FOUR, SIX, EIGHT, TEN, TWELVE, FOURTEEN, SIXTEEN,
    PETITE_ZERO, PETITE_TWO, PETITE_FOUR, PETITE_SIX, PETITE_EIGHT, PETITE_TEN,
    PETITE_TWELVE, PETITE_FOURTEEN, PETITE_SIXTEEN,
	ONEX, TWOX, THREEX, FOURX;
}

\end{shortlisting}

If the types of two mutually exclusive fields are different classes, then you
generalize these types by defining a common superclass, if possible. As a last
resort, you can combine these fields into a single field of type \class{Object}.
Finally, if there are sets of fields that are mutually exclusive, then you can
define a side class for each set of fields, where all side classes have
a common superclass. In this case, you need to do the math to make sure that you
actually save memory, given the extra cost of delegation.


\section{Redundant Fields}

A field is redundant if it stores the same information as another field but in
a different form. Why would anyone define a redundant field?  One reason is to
have a binary form for efficient computation, and a string form for
reporting. For example, a product may store both an integer and a string
representation for the productID. Since it is possible to convert one
representation into the other, there is no necessity to store both. Redundant string fields 
are a particularly
bad idea, since strings have a very high overhead in Java, as we have seen.

 %product may store both a boolean and a string ``Yes'' or ``No'' to indicate
%whether a product is in stock.  If
%the string ``Yes''
In fact, any field that can be computed on the fly is redundant and could in
principle be eliminated. For example, you can allocate a field to store the number of items
in a shopping cart, or compute it by counting all items in the cart as needed. 
There is a trade-off between the cost of the computation and the memory 
cost of the extra field, which has to be weighed in context. On the one hand,
how often is the information needed and how expensive is it to compute? On the
other hand, how many objects would there be with the computed field? Comparing
performance cost to memory cost is a bit like apples and oranges, but often it
is clear which resource is most constrained.

\section{Optimizing Framework Code}

The storage optimizations described in this chapter assume that you are
familiar with the entire application, understand how objects are created and
used, and therefore know enough to determine whether these optimizations make
sense. However, if you are programming a library or framework, you have no way
of knowing how your code will be used. In fact, it may be used in a whole
variety of different contexts with different characteristics.

A common error when programming a framework is premature optimization ---
making an assumption about how the code will be used, and optimizing for that
case. If your assumption is wrong most of the time, then your optimization may
add more cost.

Let’s come back to our low level example again, the 4-byte string \code{String}.
12 bytes of it, or 23\% of it, is due to three bookkeeping fields, an offset, a
length, and a hashcode. The offset and length fields are there to implement an optimization for
substrings. That is, when you create a substring of a string, both
the string and substring share the same character array. The offset and length
fields in the substring object specify the shared portion of the character
array. This is both a time and
space optimization, since there is no new character array created for the
substring and no copying. However, every string pays the price of the offset
and length field, whether or not they are used.
For applications with few or no substrings, which is the common case, a lot of
memory is wasted. Even when there are many substrings, if the original
strings go away, you have a different footprint problem, namely,
saving character arrays which are too big.

%It says that if I ever take a substring of this thing,
% I’m going to be able to share with the origjnal characters of the String This
 %is a theme you will see throughout the JDK, that there’s so many
% optimizations that are done to avoid copies at any cost. Really with a huge
% focus on time, and almost no focus on space whatsoever. So studies we saw at
% TRL, in reality, in the long liv

The third bookkeeping field stores a hashcode. A \code{String} stores its
hashcode, which seems like a reasonable idea, until you think about the fact
that a string needs its hashcode when it is stored in a \code{HashSet} or a
\code{HashMap}. In both of those cases, the \code{HashSet} or \code{HashMap}
entry already has a field for a hashcode, and is already storing it.
As if this redundancy isn't enough, there are also already four bytes reserved
in the object header for the identity hashcode. 

So this cautionary tale here 
is that as you design things that are higher level than this, introducing bookkeeping fields, 
people throw in extra fields to optimize performance, and footprint blows up, and it’s not even 
clear we are getting any performance out of this; in part because the benchmarks people are using 
are not really representative of the real applications out there.


This is a cautionary tale about premature optimization. The implementation of
\code{String} in the Java library is so much part the language and its
implementations that it is very hard to change at this point. Yet, strings
are so pervasive that almost all applications pay a price for this
implementation decision. 



\section{Summary}

A smattering of a lot of these little things add up.
Many of these optimizations rely on knowing how objects are used -- if you are
writing a framework, you don't know this, and the choice you make for some case
is wrong in another case.  Java makes things hard -- few choices.



