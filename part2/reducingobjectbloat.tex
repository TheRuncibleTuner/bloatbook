\chapter{Reducing Object Bloat}

In many applications, the heap is mostly filled with instances of just a
few important classes.  You can increase scalability significantly by making these
classes as compact as possible. This chapter describes field usage
patterns that can be easily optimized for space, for example, fields that are
rarely needed, constant fields, and dependent fields. Simple refactoring of
these kinds of fields can sometimes result in big wins.
 

\section{Rarely Used Fields}
\label{sec:rarely-used}

Chapter~\ref{chapter:delegation} presents examples where delegating fields
to another class increases memory cost. However, sometimes delegation can
actually save memory, if you don't have to allocate the delegated object all the
time.

As an example, consider an on-line store with millions of products. 
Most of the products are supplied by the parent company, but
sometimes the store sells products from another company:
\begin{shortlisting} 
class Product {
	String sku;
	String name;
	..
	String alternateSupplierName;
	String alternateSupplierAddress;
	String alternateSupplierSku;
}
\end{shortlisting}
When there is no alternate supplier, the last three fields
are never used. By moving these fields to a separate side class, you can
 save memory, provided the side object is allocated only when
it is actually needed. This is called \emph{lazy allocation}. Here are the 
refactored classes:

\begin{shortlisting} 
class Product {
	String sku;
	String name;
	.. 
	Supplier alternateSupplier;
}

class Supplier {
	String supplierName;
	String supplierAddress;
	String sku;
}
\end{shortlisting}
For products with no alternate supplier, eight bytes are saved per product,
since three fields are replaced by one. Of course, products with an alternate
supplier pay a delegation cost, including an extra pointer and object header.
An interesting question is how much total memory is actually saved? The
answer depends on the percentage of products that have an alternate supplier needing a
side object, which we'll call the \emph{fill rate}. The higher the fill rate, the less memory is 
saved. In fact, if the fill rate is too high, memory is wasted.

Figure~\ref{fig:fill-rate} shows the memory saved for different
fill rates, assuming three fields (12 bytes) are delegated. The most memory that can
be saved is 66\%, when the fill rate is
0\%. When the fill rate is 10\%, 50\% of memory is saved. 
When the fill rate is over 40\%, the memory saved is
negative, that is, memory is wasted. The lesson here is that if you aren't sure
what the fill rate is, then using delegation to save memory may end up
backfiring.
\begin{figure}
  \centering
 \includegraphics[width=.90\textwidth]{part2/Figures/chapter4/12-byte-graph.pdf}
 % \includegraphics{eight-char-string}
  \caption{This plot shows how much memory is saved or wasted by delegating 12
  bytes of memory to a side object. The x-axis is the fill rate, and the
  y-axis is the percent of memory saved.}
  \label{fig:fill-rate}
\end{figure}
In addition to the fill rate, the memory savings also depends on the
number of fields delegated. The more bytes delegated, the larger the memory
savings, assuming the same fill rate. Figure~\ref{fig:rarely-used} shows the memory
saved for different fill rates and different delegated-field sizes. Each
line represents a different delegated-field size. The bottom-most line
represents a delegated field size of 16 bytes, the next line represents 32 bytes, the next
represents 48 bytes, and so on, up to 144 bytes. As the delegated object size
increases, you can worry less about the fill rate. For example, if 32 bytes
are delegated, there is almost 90\% savings with a low fill rate, and some
memory savings with a fill rate up to 70\%. As the delegation size increases, 
the lines start to converge, since the fixed delegation cost becomes relatively
less important.
\begin{figure}
  \centering
 \includegraphics[width=.90\textwidth]{part2/Figures/chapter4/rarely-used.pdf}
 % \includegraphics{eight-char-string}
  \caption{This plot shows how much memory is saved or wasted for different
  delegate field sizes. The x-axis is the fill rate, and the y-axis is the
  percent of memory saved. Each line represents a different delegated size,
  starting from 16 bytes, going up to 144 bytes by increments of 16 bytes.}
  \label{fig:rarely-used}
\end{figure}

\callout{callout:rarely-used}{Delegation Cost Calculation}{
\index{Delegation Cost Calculation}
Assume the cost of a pointer is 4 bytes, and the cost of an object header is 8
bytes, and
\begin{eqnarray} 
B &=& the\ size\ in\ bytes\ of\ the\ delegated\ fields \nonumber \\
F &=& the\ fill\ rate\  \nonumber
\end{eqnarray}
The memory cost per object with the delegated
implementation is:
\begin{eqnarray}
D &=& F(B+8)+4 \nonumber
\end{eqnarray}
Note that every object pays a 4 byte pointer cost, and only $F$ of
the objects pay for the side object. The proportional improvement is:
\begin{eqnarray}
\frac{(B-D)}{B} &=& 1 - \frac{D}{B} \nonumber \\
&=& 1 - \frac{(F(B+8)+4)}{B} \nonumber
\end{eqnarray}
The following equation can be used to obtain the plots in
Figures~\ref{fig:fill-rate} and~\ref{fig:rarely-used}, for different values of
$B$:
\begin{eqnarray}
y &=& 100*(1 - \frac{\frac{x}{100}(B+8)+4}{B}) \nonumber
\end{eqnarray}
} 
A common error is to delegate rarely-used fields to a side class, but forget to
lazily allocate it, that is, always allocate a side object. 
In this case, instead of saving memory, you pay the full cost of delegation as well as 
the cost of unused fields. 
Lazy allocation
can be error-prone, since it may require testing whether the object exists at
every use. This complexity has to be weighed against potential memory
savings.

\section{Constant Fields}
\label{sec:constant}

Declaring a constant field \code{static} is a simple way to
save memory. Programmers usually remember to make constants like \emph{pi} 
static. There are other situations that are a bit more subtle, for example,
when a field is constant because of how it is used in context of the
application.

Returning to the product example, suppose that each product has a field
\code{catalog} that points to a store catalog.
If you know that there is always just one store catalog, then the field
\code{catalog} can be turned into a static, saving 4 bytes per product.

As a more elaborate example, suppose that a \class{Product} has a field
referencing a \class{Category} object, where a category may be
books, music, clothes, toys, etc.
The categories are clearly not the same across all products.
However, suppose we define
subclasses \class{Book}, \class{Music}, and \class{Clothing} of \class{Product}, 
and all instances of a subclass belong to the same category.  
Now the \code{category} field is the same for products in each subclass,
so it can be declared static:

\begin{shortlisting} 
class Book extends Product {
	static Category bookCategory; 	// points to the book category object  
	..
}

class Music extends Product {
	static Category musicCategory;  // points to the music category object
	..
}

class Clothing extends Product {
	static Category clothingCategory;  // points to the clothing category object
	.. 
}
\end{shortlisting}

Knowing the context of how objects are created and used, and how they relate to
other objects, is helpful in making these kinds of memory optimizations.


\section{Mutually Exclusive Fields}
\label{sec:mutually-exclusive}

Sometimes a class has fields that are never used at the same time, and therefore
they can share the same space. Unfortunately, Java does not have anything like
a union type, so to conflate several fields into one field, the fields have
to be of the same type. If the fields are not the same type or have the same
base type, then a new type must be created that is a generalization of the
mutually exclusive field types.

For example, suppose that each women's clothing product has a size, and there
are different kinds of sizes: xsmall-small-medium-large-xlarge,
numeric sizes, petite sizes, and large women's sizes. One way
to implement this is to introduce a field for each kind of size:
\begin{shortlisting}
class WomensClothing extends Product {
	static Category clothingCategory;  // points to the clothing category object
	..
	SMLSize     smlSize;
	NumericSize  numSize;
	PetiteSize   petiteSize;
	WomensSize   womensSize; 
}
\end{shortlisting}
Each type is an enum class, such as:
\begin{shortlisting}
enum SMLSize {
	XSMALL, SMALL, MEDIUM, LARGE, XLARGE;
}

enum NumericSize {
	ZERO, TWO, FOUR, SIX, EIGHT, TEN, TWELVE, FOURTEEN, SIXTEEN;
}

enum PetiteSize {
    ZERO, TWO, FOUR, SIX, EIGHT, TEN, TWELVE, FOURTEEN, SIXTEEN;
}

enum WomensSize {
	ONEX, TWOX, THREEX, FOURX;
}
\end{shortlisting}
These four size fields are mutually exclusive --- a clothing item cannot
have both a petite size and a women's size, for example. Therefore, you can
replace these fields by one field, provided that the four enum types are
combined into one enum type:
\begin{shortlisting}
class Clothing extends Product {
	static Category clothingCategory;  // points to the clothing category object
	..
	ClothingSize     size; 
}

enum ClothingSize {
	XSMALL, SMALL, MEDIUM, LARGE, XLARGE, 
	ZERO, TWO, FOUR, SIX, EIGHT, TEN, TWELVE, FOURTEEN, SIXTEEN,
    PETITE_ZERO, PETITE_TWO, PETITE_FOUR, PETITE_SIX, PETITE_EIGHT, PETITE_TEN,
    PETITE_TWELVE, PETITE_FOURTEEN, PETITE_SIXTEEN,
	ONEX, TWOX, THREEX, FOURX;
}

\end{shortlisting}

If the types of two mutually exclusive fields are different classes, then you
generalize these types by defining a common superclass, if possible. As a last
resort, you can alwyas combine these fields into a single field of type
\class{Object}. Finally, if there are sets of fields that are mutually exclusive, then you can
define a side class for each set of fields, where all side classes have
a common superclass. In this case, you need to do the math to make sure that you
actually save memory, given the extra cost of delegation.


\section{Redundant Fields}

A field is redundant if it stores the same information as another field but in
a different form. Why would anyone define a redundant field?  One reason is to
have a binary form for efficient computation, and a string form for
reporting. For example, a product may store both an integer and a string
representation for the productID. Since it is possible to convert one
representation into the other, there is no necessity to store both. Redundant string fields 
are a particularly
bad idea, since strings have a very high overhead in Java, as we have seen.

 %product may store both a boolean and a string ``Yes'' or ``No'' to indicate
%whether a product is in stock.  If
%the string ``Yes''
In fact, any field that can be computed on the fly is redundant and could in
principle be eliminated. For example, you can allocate a field to store the number of items
in a shopping cart, or compute it by counting all items in the cart as needed. 
There is a trade-off between the cost of the computation and the memory 
cost of the extra field, which has to be weighed in context. On the one hand,
how often is the information needed and how expensive is it to compute? On the
other hand, how many objects would there be with the computed field? Comparing
performance cost to memory cost is a bit like apples and oranges, but often it
is clear which resource is most constrained.

\section{Optimizing Framework Code}

The storage optimizations described in this chapter assume that you are
familiar with the entire application you are working on. You need to
understand how objects are created and used, and therefore know enough to determine
whether these optimizations make
sense. However, if you are programming a library or framework, you have no way
of knowing how your code will be used. In fact, your code may be used in a whole
variety of different contexts with different characteristics. Premature optimization ---
making an assumption about how the code will be used, and optimizing for that
case --- is a common pitfall when programming frameworks. If your assumption is
wrong most of the time, then premature optimization fails. 

For example, suppose the online store is designed as a framework
that can be extended to implement different kinds of stores.
For some stores, most products may have an alternate supplier. For other
stores, most products may not.  There is no way of knowing. If the
\code{Product} class is designed so that the alternate supplier is allocated to
a side object, then sometimes memory will be saved and sometimes wasted. 
One possibility is to define two versions of the \code{Product} class, one that
delegates and one that doesn't. The framework user can then use the version
that is appropriate to the specific context. However, this is generally not
practical. 

Frequently, decisions are made that trade space for time.
Let’s come back to our low level example again, the 8-character 
\code{String}. 12 bytes of it, or 21\% of it, is due to three bookkeeping fields, an offset, a
length, and a hashcode. The offset and length fields implement an optimization for
substrings. That is, when you create a substring of a string, both
the string and substring share the same character array, as shown in
Figure~\ref{fig:substring}. The offset and length fields in the substring
\code{String} object specify the shared portion of the character array. This optimizes both time and
space for substring operations, since there is no new character array created
for the substring and no copying. However, every string pays the price of the offset
and length field, whether or not they are used.
For applications with few or no substrings, which is the common case, a lot of
memory is wasted. Even when there are many substrings, if the original
strings go away, you have a different footprint problem, namely,
saving character arrays which are too big.
\begin{figure}
  \centering
 \includegraphics[width=.90\textwidth]{part2/Figures/chapter4/substring.pdf}
 % \includegraphics{eight-char-string}
  \caption{A string and a substring share the same character. The length and
  offset fields are needed for the substring, but store redundant information
  for the string.}
  \label{fig:substring}
\end{figure}

%It says that if I ever take a substring of this thing,
% I’m going to be able to share with the origjnal characters of the String This
 %is a theme you will see throughout the JDK, that there’s so many
% optimizations that are done to avoid copies at any cost. Really with a huge
% focus on time, and almost no focus on space whatsoever. So studies we saw at
% TRL, in reality, in the long liv

The third bookkeeping field in \code{String} is a hashcode.
Storing a hashcode seems like a reasonable idea, until you think about the fact
that a string only needs its hashcode when it is stored in a \code{HashSet} or a
\code{HashMap}. In both of these cases, the \code{HashSet} or \code{HashMap}
entry already has a field for a hashcode, and is already storing it.
As if this redundancy isn't enough, there are also four bytes reserved
in every object header for the identity hashcode. 


This is a cautionary tale. The implementation of
\code{String} in the Java library is so much part the language and its
implementations that it is very hard to change at this point. Yet, strings
are so pervasive that almost all applications pay the price of  having a larger
footprint. And it's not even clear that there is any performance gain from
these string optimizations for most applications. 
They might make a difference in certain benchmarks, but benchmarks usually do
not behave like other applications.


\section{Summary}

Even though Java does not let you control the layout of objects, it is still
possible to make objects smaller by recognizing certain usage patterns.
Optimization opportunities include:

\begin{itemize}
  \item Rarely used fields can be delegated to a side object.
  \item Fields that have the same value in all instances of a class can be
  declared static.
  \item Mutually exclusive fields can share the same field, provided they have
  the same type.
  \item Redundant fields whose value depends on the value of other fields can
  be eliminated, and recomputed each time they are used.
  \item 
\end{itemize}

Every field eliminated saves around 4 bytes per object, which may seem small.
However, often several optimizations can be applied to a class, and if the
class has the most objects in the heap, then these small optimizations turn out
to be significant. 

