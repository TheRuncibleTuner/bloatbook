\section{Avoiding Lifetime Bugs}
\label{avoiding-lifetime-bugs}

A memory leak is a bug that results from mistakenly retaining references to
objects that the application no longer needs. The lifetime of these leaked
objects will be, by accident, infinite, even though their natural lifetime, the
interval during which they are used, is not. In the cases where correctness
requires that the actual lifetime of an object match its natural lifetime, you
can use a variety of mechanisms to ensure that this is the case. Doing so is
often tricky, because the built-in mechanisms that the Java language and runtime
provide for managing object lifetime do not align with many of the common use
cases. You must assume the burden of lifetime management and it is important to
avoid the common pitfalls.


\begin{itemize}
\item leaks
\item drags
\item oops doesn't fit in memory!!
\item oops marshalling costs dwarf real work!!
\item using too complicated a mechansim to maintain correlation
\item by lengthening lifetime, you can create a contention problem
	e.g. converter stored in synchronized thread local
	e.g. concurrent cache
\item sometimes (overhead of lifetime management) weak references are relatively expensive to data
\item make sure you bound size of cache to a reasonable number (hard to get right)
\end{itemize}
