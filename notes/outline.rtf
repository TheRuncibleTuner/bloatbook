{\rtf1\ansi\ansicpg1252\deff0{\fonttbl{\f0\fswiss\fcharset0 Helvetica;}}
{\*\generator Msftedit 5.41.15.1515;}\viewkind4\uc1\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\lang1033\b\f0\fs24 Outline\par
\b0\par
Preface\par
\par
List of Figures\par
\par
List of Tables\par
\pard\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\par
\pard\fi-360\li360\tx0\tx360\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 1.\tab Introduction\par
\pard\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\par
\b Section I. Using Space\b0  (The Costs of Data? Cost-conscious Data Design? Data Design and Space Costs?)\par
\pard\fi-720\li720\tx0\tx360\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 2.\tab Memory Health\par
\par
3.\tab Object and Delegation Costs\par
\tab 3.1 The Cost of Objects\par
\tab 3.2 The Cost of Delegation\par
\tab 3.3 Fine-grained Data Models\par
\tab 3.4 Large Base Classes\par
\tab 3.5 64-bit Architectures\par
\tab 3.6 Summary\par
\par
4.\tab Reducing Object Bloat\par
\tab Intro\par
\tab 4.1 Rarely Used Fields\par
\tab 4.1.1 Attribute Table\par
\tab 4.2 Constant Fields\par
\tab 4.3 Mutually Exclusive Fields\par
\tab 4.4 Redundant Representations\par
\tab 4.5 Writing Efficient Framework Code\par
\tab 4.6 Summary\par
\par
5. Representing (more complex) values\par
\tab\tab 1. String data\par
\tab\tab\tab 1.1. String vs. scalar representations (bool, int, enum). \i Overlaps with section on redundant fields.  Ideally would be before that section.\i0\par
\tab\tab\tab 1.2 String vs. StringBuffer\par
\tab\tab 2. More complex values\par
\tab\tab\tab 2.1 Date (and Calendar?)\par
\tab\tab\tab 2.2 BigInteger and BigDecimal\par
\par
6.\tab Sharing Immutable Data\par
\tab Intro.  Includes discussion of compile-time vs. runtime data.\par
\tab 5.1 Compile-time constant data\par
\tab\tab 5.1.1 String literals\par
\tab\tab 5.1.2 Enums\par
\tab 5.2 The sharing pool concept\par
\tab 5.3 String interning\par
\tab 5.4 Sharing boxed scalars\par
\tab 5.5 Sharing more complex data.  Discuss stability issues, and refer to lifetime sections for safe sharing when data is in flux.\par
\par
\pard\li360\tx360\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 a. scalar vs. String representations\par
b. String vs. StringBuffer\par
c. enum vs. String\par
d. sharing Strings\par
e. sharing scalars (including enum)\par
f. sharing more complex data\fs26\par
\pard\fi-720\li720\tx0\tx360\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\fs24\par
6.\tab Reducing Collection Bloat\par
7.\tab Nested Collections\par
8.\tab Specialized Collections\par
\pard\tx360\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\fs26\tab\par
\pard\li360\tx360\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\fs24\par
\pard\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\b\par
Section II. Managing the Lifetime of Data\par
\b0\par
\pard\tx360\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 9.\tab Lifetime Requirements\par
\pard\fi-360\li1080\tx560\tx1080\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 a.\tab Intro: the importance of understanding your application\rquote s requirements, and what's possible to achieve.\par
b.\tab Object Lifetimes in a Web Application Server\par
c.\tab Temporaries (including at least an overview of cost problem)\par
d.\tab Correlated lifetime (including correlated with external event)\par
e.\tab Time-space tradeoffs\par
f.\tab Permanently resident data\par
\pard\li720\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\i Order of c - f: roughly in order of duration.\par
Where to discuss costs of temporaries in detail. Here or in 12?\par
Pointers with each topic to sections that discuss solutions.\par
\pard\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\i0\par
\pard\tx360\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 10.\tab Memory Management Fundamentals\par
\pard\fi-360\li1080\tx560\tx1080\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 a.\tab Managed memory. Native vs. Java; max/fixed heap size; basic GC; references vs. pointers, no stack objects, and other differences from C (or move to next section)\par
b.\tab Lifecycle of an object. Basic cases of references (strong only), and how objects are freed (locals, field/array refs, statics); implicit / explicit releasing of objects; concept of drag; concept of leaks in Java. Basic ideas of GC (reachability/ownership).\par
c.\tab Mechanisms to help manage lifetime. High-level intro in this section. Best practices and traps explained in next two chapters in the context of use cases. Some high-level mention of traps.\par
\pard\fi-180\li1800\tx560\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 i.\tab weak/soft references. HIgh-level overview of function, why you'd use them, and comparison. Same for WeakHashMap and reference queues (overview).\par
ii.\tab finalizers and phantom references\par
iii.\tab thread-local storage\par
iv.\tab class unloading and statics (\i or move this to 13\i0 ?)\par
\pard\li1620\tx560\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\i Something on managing native memory (e.g. class files?)\i0\par
\pard\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\par
\pard\tx360\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 11.\tab Avoiding Leaks: Correlated Lifetime Patterns. \par
\pard\li720\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\i Sound implementation practices and traps for each topic.\par
\pard\fi-360\li1080\tx560\tx1080\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\i0 a.\tab Brief intro. Include definition of memory leak.\par
b.\tab Tools: Weak references, WHMs and alternatives.\par
c.\tab Annotations\par
d.\tab Saving space: sharing immutable data safely\par
\pard\fi-180\li1800\tx560\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 i.\tab Brief review of cases covered in Section I (enums, interning, etc.)\par
ii.\tab Implementing a sharing pool using a custom (or off-the-shelf) RefMap<strong, weak>.\par
iii.\tab Show annotation pool as a secondary example, showing traps of weak refs in more complex case\par
\pard\fi-360\li1080\tx560\tx1080\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 e.\tab Request/phase-scoped data\par
f.\tab Cleaning up: listeners\par
g.\tab Cleaning up: using finalizers and phantom references\par
h.\tab The Single Strong Owner pattern. Revisit some earlier examples showing how this approach can help.\par
\pard\li720\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\par
\pard\tx360\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 12.\tab Trading Space for Time: Caches, Resource Pools, and Thread-local Stores\par
\pard\li720\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\i Sound implementation practices and traps for each topic.\i0\par
\pard\fi-360\li1080\tx560\tx1080\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 a.\tab Tools: Soft references\par
b.\tab Caches\par
c.\tab Resource pools (including comparison with caches)\par
d.\tab Avoiding leaks while optimizing for time.  Cover some hybrid cases here, e.g. Session State; avoiding leaks in caches; a sharing pool that keeps data around a little longer just in case\par
e.\tab Avoiding contention with thread-local storage\par
\pard\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\par
\pard\tx360\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 13.\tab Advanced Techniques (Customization and Tuning?)\par
\pard\fi-360\li1080\tx560\tx1080\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 a.\tab Working with reference queues\par
b.\tab Implementing a concurrent cache\par
c.\tab Tuning garbage collection. Includes more details on how GC works.\par
d.\tab Large arrays and perm space (research - may not need)\par
\pard\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\par
\par
\b\par
Section III. Scalability\b0\par
\par
\pard\tx360\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 14.\tab Assessing Scalability\par
\tab a.Quantitative methodology: Will it fit?\par
\pard\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\par
\pard\tx360\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 15.\tab Pushing the Limits of Object-orientation\par
\pard\fi-360\li1080\tx560\tx1080\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 a.\tab Bulk storage and sharing of string data\par
b.\tab Representing relationships. Discuss graph edges early on as an important case.\par
\pard\li720\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\i Possibly combine this and the next chapter, under the title Extreme Scalability.  Then could combine discussions of bulk storage of string data.\par
\pard\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\i0\par
\pard\tx360\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 16.\tab Breaking the Mold of Object-orientation (Extreme Scalability?)\par
\pard\fi-360\li1080\tx560\tx1080\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 a.\tab Column-oriented storage\par
b.\tab Representing relationships using column-oriented storage\par
c.\tab Representing variable-length data using column-oriented storage\par
d.\tab Limitations of column-oriented storage (advantages & limitations?)\par
\pard\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\par
\pard\tx360\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 17.\tab Working with Secondary Stores\par
\pard\fi-360\li1080\tx560\tx1080\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 a.\tab Serialization. Cover the spectrum of serialization techniques, their pros and cons, and when to use each.\par
b.\tab Memory mapping.\par
\pard\fi-180\li1800\tx560\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 i.\tab intro to memory mapping\par
ii.\tab memory mapping in Java\par
iii.\tab breaking the \endash Xmx barrier\par
iv.\tab memory mapping column-oriented storage\par
v.\tab difficulties with memory mapping in Java\par
\pard\tx560\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\par
\b\par
Appendices\par
\b0\par
Appendix A. Tools to Help Memory Analysis\par
\par
Appendix B. JVM Options Related to Memory\par
\par
Appendix C. A Comparison of Space Costs on JREs\par
\par
Index\par
\par
}
 